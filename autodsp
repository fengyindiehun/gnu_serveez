#! /usr/local/bin/perl
#
# autodsp -- Run this script to re-generate all Windows projects.
#
# Copyright (C) 2001 Stefan Jahn <stefan@lkcc.org>
#
# This is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
# 
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this package; see the file COPYING.  If not, write to
# the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.  
#
# $Id: autodsp,v 1.1 2001/11/24 00:08:50 ela Exp $
#

use strict;

my $VERSION = "1.0.0";
my $PACKAGE = "Autodsp";
my $verbose = 0;
my @input_files = `find . -name "*.ap" -type f`;

check_arguments (@ARGV);

foreach (@input_files) {
    my $file = $_;
    chop $file;
    create_ap ($file, read_ap ($file));
}

#
# check the command line
#
sub check_arguments {

    my (@args) = @_;

    while (@args) {

	if (@args[0] eq "--verbose") {
	    $verbose = 1;
	} elsif (@args[0] eq "--version") {
	    print "$PACKAGE $VERSION\n";
	    exit 0;
	} elsif (@args[0] eq "--help") {
	    print "  --version            print version number, then exit\n";
	    print "  --help               display this help message\n";
	    print "  --verbose            list processed file(s)\n";
	    exit 0;
	}
	shift @args;
    }
}

#
# convert -l linker flags
#
sub replace_libs {

    my $libs = "";
    foreach (split (/ /, shift @_)) {
	s/^-l(\S+)$/lib$1\.lib/;
	$libs .= " " . $_;
    }
    return $libs;
}

#
# convert -L linker flags
#
sub replace_ldflags {

    my ($ldflags, $prefix) = @_;
    my $flags = "";
    foreach (split (/ /, $ldflags)) {
	s/^-L(\S+)$/\/libpath:\"$1\/$prefix\"/;
	$flags .= " " . $_;
    }
    return $flags;
}

#
# convert -D cpp flags
#
sub replace_defs {

    my $defs = "";
    foreach (split (/ /, shift @_)) {
	if (/^-D(\S+)=(.*)$/) {
	    $_ = "/D $1=$2";
	} else {
	    s/^-D(\S+)$/\/D \"$1\"/;
	}
	$defs .= " " . $_;
    }
    return $defs;
}

#
# convert -I cpp flags
#
sub replace_includes {

    my $includes = "";
    foreach (split (/ /, shift @_)) {
	s/^-I(\S+)$/\/I \"$1\"/;
	$includes .= " " . $_;
    }
    return $includes;
}

#
# creates DSP (Developer Studio Project) file or DSW (Developer Studio 
# Workspace) file depending on the target type
#
sub create_ap {

    my ($file, %variables) = @_;

    die "autodsp: No TARGET_TYPE specified\n" unless 
	defined $variables{'TARGET_TYPE'};

    if ($variables{'TARGET_TYPE'} =~ /project/i) {
	create_dsw ($file, %variables);
    } else {
	create_dsp ($file, %variables);
    }
}

#
# creates a Workspace file
#
sub create_dsw {

    my ($infile, %variables) = @_;
    local (*OUT_FILE);
    my ($f, $s, $orgfile, $p, $file);

    # create output file
    $file = $infile;
    $orgfile = $file;
    $file =~ s/^(.*)\.ap$/$1\.in/;
    open (OUT_FILE, ">".$file) || 
	die "autodsp: couldn't create \`$file': $!\n";
    print "autodsp: creating $file\n" if $verbose;

    # check OWNER; then print file header
    die "autodsp: No OWNER specified\n" unless defined $variables{'OWNER'};
    print OUT_FILE 
	"Microsoft Developer Studio Workspace File, " .
	"Format Version 5.00\r\n";

    # print Autodsp header
    $orgfile = `basename $orgfile`; chop $orgfile;
    $file = `basename $file`; chop $file;
    print OUT_FILE
	"#\r\n" .
	"# $file generated by $PACKAGE $VERSION from $orgfile\r\n" .
	"#\r\n\r\n";

    # check PROJECTS; then print all
    die "autodsp: No PROJECTS specified\n" 
	unless defined $variables{'PROJECTS'};
    foreach $s (split (/ /, $variables{'PROJECTS'})) {

	$p = `basename $s`;
	chop $p;
	$f = $s;
	$f =~ s/\//\\/g;
	$f .= ".dsp";

	print OUT_FILE
	    "Project: \"" . $p . "\"=\"" . $f . "\"" .
	    " - Package Owner=" . $variables{'OWNER'} . "\r\n\r\n";

	# check dependencies
	if (defined ($variables{$p."_DEPENDENCIES"})) {

	    print OUT_FILE
		"Package=" . $variables{'OWNER'} . "\r\n" .
		"{{{\r\n" .
		"    Begin Project Dependency\r\n";
	    # output each dependency
	    foreach (split (/ /, $variables{$p."_DEPENDENCIES"})) {
		print OUT_FILE 
		    "    Project_Dep_Name " . $_ . "\r\n";
	    }
	    print OUT_FILE
		"    End Project Dependency\r\n" .
		"}}}\r\n";
	}
    }

    close (OUT_FILE);
    return;
}

#
# creates a Project file
#
sub create_dsp {

    my ($infile, %variables) = @_;
    local (*OUT_FILE);
    my ($s, $type, %types, $orgfile, $file);

    # types of targets
    %types = (
	      "0x0103" => "\"Win32 (x86) Console Application\"",
	      "0x0102" => "\"Win32 (x86) Dynamic-Link Library\"",
	      );

    # create output file
    $file = $infile;
    $orgfile = $file;
    $file =~ s/^(.*)\.ap$/$1\.in/;
    open (OUT_FILE, ">".$file) || 
	die "autodsp: couldn't create \`$file': $!\n";
    print "autodsp: creating $file\n" if $verbose;

    # check OWNER and TARGET; then print file header
    die "autodsp: No OWNER specified\n" unless defined $variables{'OWNER'};
    die "autodsp: No TARGET specified\n" unless defined $variables{'TARGET'};
    print OUT_FILE 
	"# Microsoft Developer Studio Project File - Name=\"" . 
	$variables{'TARGET'} . 
	"\" - Package Owner=" . $variables{'OWNER'} . "\r\n";
    print OUT_FILE
	"# Microsoft Developer Studio Generated Build File, " .
	"Format Version 5.00\r\n";

    # print Autodsp header
    $orgfile = `basename $orgfile`; chop $orgfile;
    $file = `basename $file`; chop $file;
    print OUT_FILE
	"#\r\n" .
	"# $file generated by $PACKAGE $VERSION from $orgfile\r\n" .
	"#\r\n\r\n";

    # check TARGET_TYPE; then print it
    $s = $variables{'TARGET_TYPE'};
    if ($s =~ /console.*app/i) {
	$type = "0x0103";
    } elsif ($s =~ /dll/i) {
	$type = "0x0102";
    } else {
	die "autodsp: Invalid TARGET_TYPE specified in \`$file'\n";
    }
    print OUT_FILE "# TARGTYPE " . $types{$type} . " " . $type . "\r\n\r\n";

    # these !MESSAGE's are necessary
    print OUT_FILE "!MESSAGE There are 2 configurations:\r\n";
    print OUT_FILE
	"!MESSAGE \"" . $variables{'TARGET'} . " - Win32 Release\" " .
	"(based on " . $types{$type} . ")\r\n";
    print OUT_FILE
	"!MESSAGE \"" . $variables{'TARGET'} . " - Win32 Debug\" " .
	"(based on " . $types{$type} . ")\r\n";

    # output project header
    print OUT_FILE "\r\n# Begin Project\r\n";
    print OUT_FILE 
	"CPP=cl.exe\r\n" . 
	"RSC=rc.exe\r\n" . 
	"BSC32=bscmake.exe\r\n" . 
	"LINK32=link.exe\r\n" . 
	"MTL=midl.exe\r\n";

    # generate release target
    print OUT_FILE 
	"\r\n!IF \"\$(CFG)\" == \"" . $variables{'TARGET'} . 
	" - Win32 Release\"\r\n\r\n";
    print OUT_FILE create_opt ($type, %variables);

    # generate debug target
    print OUT_FILE 
	"\r\n!ELSEIF \"\$(CFG)\" == \"" . $variables{'TARGET'} . 
	" - Win32 Debug\"\r\n\r\n";
    print OUT_FILE create_dbg ($type, %variables);

    print OUT_FILE "\r\n!ENDIF\r\n\r\n";

    # print target header
    print OUT_FILE 
	"# Begin Target\r\n" .
	"# Name \"" . $variables{'TARGET'} . " - Win32 Release\"\r\n" .
	"# Name \"" . $variables{'TARGET'} . " - Win32 Debug\"\r\n\r\n";

    # check SOURCES; then print all
    die "autodsp: No SOURCES specified\n" 
	unless defined $variables{'SOURCES'};
    foreach $s (split (/ /, $variables{'SOURCES'})) {
	print OUT_FILE
	    "# Begin Source File\r\n" .
	    "SOURCE=\"" . $s . "\"\r\n" .
	    "# End Source File\r\n\r\n";
    }

    # print target and project footer
    print OUT_FILE
	"# End Target\r\n" .
	"# End Project\r\n";

    close (OUT_FILE);
    return;
}

#
# returns linker and cflags depending on the $debug variable and the 
# target type (DLL or Application)
#
sub check_target_type {

    my ($type, $debug) = @_;
    my ($submode, $mtl, $subsys);

    if ($type eq "0x0102") {
	$type = "dll";
	$submode = $debug . " /D \"_WINDOWS\"";
	$mtl = "# ADD MTL /nologo " . $debug . 
	    " /mktyplib203 /o NUL /win32\r\n";
	$subsys = "/subsystem:windows /dll";
    } elsif ($type eq "0x0103") {
	$type = "app";
	$submode = $debug . " /D \"_CONSOLE\" /D \"_MBCS\"";
	$mtl = "";
	$subsys = "/subsystem:console";
    }
    return ($type, $submode, $mtl, $subsys);
}

#
# generates the Release target
#
sub create_opt {

    my ($type, %variables) = @_;
    my ($debug, $ret, $s, $submode, $mtl, $subsys, $t);
    
    $t = $type;
    $debug = "/D \"NDEBUG\"";
    ($t, $submode, $mtl, $subsys) = check_target_type ($t, $debug);

    $ret = 
	"# PROP Use_MFC 0\r\n" .
	"# PROP Use_Debug_Libraries 0\r\n" .
	"# PROP Output_Dir \"Opt\"\r\n" .
	"# PROP Intermediate_Dir \"Opt\"\r\n" .
	"# PROP Ignore_Export_Lib 0\r\n" .
	"# PROP Target_Dir \"\"\r\n";

    $ret .= "# ADD CPP /nologo /MD /W3 /GX /O2 /Ob2";
    if (defined $variables{'INCLUDES'}) {
	$ret .= replace_includes ($variables{'INCLUDES'});
    }
    $ret .= " /D \"WIN32\" " . $submode;
    $ret .= " /D \"__MINGW32__\" /D \"HAVE_CONFIG_H\" /D __STDC__=0"; 
    if (defined $variables{'DEFS'}) {
	$ret .= replace_defs ($variables{'DEFS'});
    }
    if (defined $variables{'opt_DEFS'}) {
	$ret .= replace_defs ($variables{'opt_DEFS'});
    }
    $ret .= " /FD /c\r\n";

    $ret .= $mtl;
    $ret .= "# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n";
    $ret .= "# ADD BSC32 /nologo\r\n";
    
    $ret .= "# ADD LINK32 kernel32.lib";
    if (defined $variables{'LIBS'}) {
	$ret .= replace_libs ($variables{'LIBS'});
    }
    $ret .= " /nologo " . $subsys . " /pdb:none /machine:I386";
    if (defined $variables{'LDFLAGS'}) {
	$ret .= replace_ldflags ($variables{'LDFLAGS'}, "Opt");
    }
    $ret .= "\r\n";
    
    return $ret;
}

#
# generates the Debug target
#
sub create_dbg {

    my ($type, %variables) = @_;
    my ($debug, $ret, $s, $submode, $mtl, $subsys, $t);
    
    $t = $type;
    $debug = "/D \"_DEBUG\"";
    ($t, $submode, $mtl, $subsys) = check_target_type ($t, $debug);
    
    $ret = 
	"# PROP Use_MFC 0\r\n" .
	"# PROP Use_Debug_Libraries 1\r\n" .
	"# PROP Output_Dir \"Dbg\"\r\n" .
	"# PROP Intermediate_Dir \"Dbg\"\r\n" .
	"# PROP Ignore_Export_Lib 0\r\n" .
	"# PROP Target_Dir \"\"\r\n";

    $ret .= "# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od";
    if (defined $variables{'INCLUDES'}) {
	$ret .= replace_includes ($variables{'INCLUDES'});
    }
    $ret .= " /D \"WIN32\" " . $submode;
    $ret .= " /D \"__MINGW32__\" /D \"HAVE_CONFIG_H\" /D __STDC__=0"; 
    if (defined $variables{'DEFS'}) {
	$ret .= replace_defs ($variables{'DEFS'});
    }
    if (defined $variables{'dbg_DEFS'}) {
	$ret .= replace_defs ($variables{'dbg_DEFS'});
    }
    $ret .= " /FD /c\r\n";

    $ret .= $mtl;
    $ret .= "# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n";
    $ret .= "# ADD BSC32 /nologo\r\n";
    
    $ret .= "# ADD LINK32 kernel32.lib";
    if (defined $variables{'LIBS'}) {
	$ret .= replace_libs ($variables{'LIBS'});
    }
    $ret .= " /nologo " . $subsys . " /pdb:none /debug /machine:I386";
    if (defined $variables{'LDFLAGS'}) {
	$ret .= replace_ldflags ($variables{'LDFLAGS'}, "Dbg");
    }
    $ret .= "\r\n";
    
    return $ret;
}

#
# read a single .ap file and return a var->value hash
#
sub read_ap {

    my ($file) = @_;
    local (*IN_FILE);
    my ($line, $var, $value, %ret);

    open (IN_FILE, $file) || die "autodsp: couldn't open \`$file': $!\n";
    print "autodsp: reading $file\n" if $verbose;

    while (<IN_FILE>) {

	# clear end of lines; skips comments
	$line = $_;
	$line =~ s/\r\n//g;
	$line =~ s/\n//g;
	$line =~ s/^(.*)\#.*/$0/;

	# continues reading after trailing '\'
	while ($line =~ m/^.*\\$/) {
	    chop $line;
	    $line .= " " . <IN_FILE>;
	    $line =~ s/\r\n//;
	    $line =~ s/\n//;
	    $line =~ s/^([^\#]*)\#.*/$1/;
	}

	# drop tabs and replace double spaces
	$line =~ s/\t/ /g;
	$line =~ s/[ ]+/ /g;

	# parse VAR=VALUE assignments
	if ($line =~ m/^([^=]*)=(.*)$/) {
	    $var = $1;
	    $value = $2;
	    $var =~ s/^\s*(\S*)/$1/;
	    $var =~ s/(\S*)\s*$/$1/;
	    $value =~ s/^\s*(\S*)/$1/;
	    $value =~ s/(\S*)\s*$/$1/;
	    $ret{$var} = $value;
	}
    }
    close (IN_FILE);
    return %ret;
}
