\input texinfo
@c %**start of header
@setfilename serveez.info
@settitle Serveez Documention
@c %** end of header

@set VERSION 0.0.17pre

@titlepage
@title Serveez
@subtitle Documentation
@subtitle Version @value{VERSION}
@author Stefan Jahn
@author Raimund Jacob
@page
@vskip 0pt plus 1filll

Copyright @copyright{} 2000 Stefan Jahn @email{stefan@@lkcc.org}@*
Copyright @copyright{} 2000 Raimund Jacob @email{raimi@@lkcc.org}@*
Copyright @copyright{} 1999 Martin Grabmueller @email{mgrabmue@@cs.tu-berlin.de}@*

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1
or any later version published by the Free Software Foundation.
A copy of the license is included in the section entitled "GNU
Free Documentation License".

@end titlepage

@node Top, (dir), (dir), (dir)

@menu
* Introduction::        Introduction to Serveez
* Using Serveez::       Startup and command line options
* Concept::             Conceptional thoughts
* Server::              Server implementation
* Co-Server::           Co-Server implementation
* Porting issues::      Support of different platforms and operating systems
@end menu

@node Introduction, Using Serveez, ,Top
@chapter Introduction

Serveez is a server listening on a multiple tcp ports and handling all
client connections within a single process (non forking behaviour). The
overall concept is as loose as neccessary and possible. The server is able
to handle various internet protocols and can be run on different platforms
and operating systems. Until now we implemented our own chat protocol, 
the IRC protocol, HTTP and an internal control protocol.

@node Using Serveez, Concept, Introduction, Top
@chapter Using Serveez

@section Starting Serveez

To start Serveez simply type @samp{serveez} at your command line prompt
and press @key{RET}. This will invoke the @file{serveez.[exe]} which will
read its configuration from a file called @file{serveez.cfg} in the current
directory and run the server loop afterwards. Press @key{^C} to abort the
execution of this program.

@section Command line options

@table @code

@item -h, --help
Display this help and exit.
@item -V, --version
Display version information and exit.
@item -i, --iflist
List local network interfaces and exit.
@item -f, --file=FILENAME
File to use as configuration file (serveez.cfg).
@item -v, --verbose=LEVEL
Set level of logging verbosity.
@item -l, --log-file=FILENAME
Use FILENAME for logging (default is stderr).
@item -P, --password=STRING
Set the password for control connections.
@item -m, --max-sockets=COUNT
Set the maximum number of socket descriptors.

@end table

@node Concept, Server, Using Serveez, Top
@chapter Concept

@node Server, Co-Server, Concept, Top
@chapter Server

@menu
* Introduction to Servers::     Protocol servers in Serveez
* Writing Servers::             How to write internet protocol servers
* Existing Servers::            Which kind of servers do we have already ?
@end menu

@node Introduction to Servers, Writing Servers, , Server
@section Introduction to Servers

This package includes a kind of server server. It allows different 
protocol servers to listen on various TCP/IP ports and server instanciating.
Thus it is possible to to have different servers on the same TCP/IP port.

This chapter covers all questions about how to write your own internet
protocol server with little help of this package. Most of the usual tasks of
such a server have got their generic solutions which could be shadowed by 
your own routines. There are some examples within this package showing the
possibilities and one very simple example how to implement such a server.

The foo server does not do anything at all and is of no use actually
but could be a basis for a new protocol server. We are now going to describe
how this specific server works. Eventually the reader might have got an idea
what is going on here.

@node Writing Servers, Existing Servers ,Introduction to Servers, Server
@section Writing Servers

@subsection Making and configuring preperations

Serveez is configured and build via automake and autoconf. That
is why you are not supposed to write your own Makefiles but simplified
@file{Makefile.am}s. Automake will automatically generate dependencies and
compiler and linker command lines. Here are the steps you basically need 
to follow:

@itemize @bullet
@item
Change to the @file{src/} directory in the source tree.

@item
Edit the @file{Makefile.am}. Add your sub directory name and library name
which you are going to create.

@item
Now create the sub directory and change into it.

@item
You need to create a new @file{Makefile.am} therein. You have to put at least
the following into it:

@example
noinst_LIBRARIES = libfoo.a
AM_CPPFLAGS = -I..
CLEANFILES = *~
libfoo_a_SOURCES = foo-proto.h foo-proto.c
@end example

@item
Just have a look at all the other server directories. For more information
about automake read the info pages.

@end itemize

@subsection Server header file @file{foo-proto.h}

This file contains at least your servers configuration structure and
some global definitions of server routines which must be available outside.
Furthermore it contains the global definition of your server definition. The
foo server implements all kinds of configurations items which could be
integers, string arrays, strings, integer arrays, port configurations and
hashes. Every thing within this configuration will be configurable within
the configuration file later.

@subsection Server implementation file @file{foo-proto.c}

If you want to define default values for your configuration you have
to define it somewhere and put it into the default configuration structure.
This structure will be used to instanciate your server. In this case we 
called it simply `mycfg'.

In order to associate the configurations items in a server 
configuration to keywords within the configuration file you have to define a
array of key-value-pairs. This is done in the `foo_config_prototype' field.
There are several macros which make different associations. These are the
REGISTER_* macros which take three arguments. The first argument is the
keyword which will occur in the configuration file, the second is the
associated item in your default configuration structure and the last argument
specifies if this item is defaultable or not.

@subsection Server definition

The server definition is the representation of your server object 
which will be instanciatable. You have to put in this structure a long and
a short description of your server. The short name will be used to instanciate
the server object via the configuration file. You can instanciate it by
writing @code{(define foo-server1 '#@{ ... @})} where @code{foo} is your 
servers short name. Moreover you have to put there the server 
callbacks which will be described later and the configuration 
associations described above.

@subsection Server callbacks

There are several callback routines, which get called in order to 
instanciate the server and for describing the actual behaviour of your server.
Here is the description of all of these.

@table @asis

@item global initializer (optional)

This callback is executed once for initializing the server. Here you can
initialize data or whatever shared by all instances of your server. For
instance the http server would load the mime type file here. The foo
server creates its default hash property because a hash cannot be
statically initialized.

@item global finalizer (optional)

If you want to free shared resources which were possibly allocated within
the global initializer you can do so here. The foo server frees its
default hash previouly allocated in the global initializer.

@item instance finalizer (optional)

The server instance finalizer gets its instance representation as argument.
You have to free all resources used by this server instance. The foo server
destroys its hash if it was not the default hash which gets freed within
the global finalizer.

@item instance initializer (mandatory)

Within this routine you can initialize all you might need for one instance
of your server. Secondly you have to bind this instance to some port
configuration. In most cases you want to have this port configuration
accessable via the configuration file. Therefore you have to 
REGISTER_PORTCFG () in your servers configuration definition. The port
configuration is then part of your servers instance configuration
structure. The foo server prints its whole configuration just for debugging
purposes. It simply shows how configurable items from the configuration
file fall to the server instance configuration. If you are going to plan
that one server instance listens on different ports you can do so.

@item protocol detection (mandatory)

Because it is possible to have more than one server listening on one 
network port we are going to detect the type of client which is connecting
to this port. The foo servers checks if the first five bytes the client
was sending is identifying it as a foo client. This routine is getting
two arguments where the first one is a pointer to this servers instance
configuration and the second is the client socket object containing all
information of the client connection. This structure is describe a bit
later. Be patient. For successful client detection return non-zero 
otherwise zero.

@item connect socket (mandatory)

If the client detection signaled success this routine is called to assign
the client connection to this servers instance. The arguments are just
the same as in the detection routine. In this callback you can assign
all the connection specific callbacks for your server and do some initial
things. The foo server sets the check_request callback to the 
default_check_request which is using the packet delimiter information to
find whole packets. When a client sent such a packet the handle_request
callback is executed. That is why the foo server assigns the handle_request
method.

@end table

@subsection Make your server available

You distribute your server by editing the @file{server.c} file in the
@file{src/} directory. There you have to include the the servers header 
file and add the server definition to the @code{all_server_definition} array.

@subsection More detailed description of the callback system and structures

The client connection information is stored within the socket_t 
object. All of the client connection specific callbacks get this object as
first argument. Here follows a decription of the elements of this object.

@table @code

@item socket_id
The socket id is a unique id for a client connection.

@item flags
The flag field of the client connection contains informations about the
state of this connection. See @file{socket.h} in the @file{src/} directory 
for more information. Basically this bitfield specifies how this object
is handle by the main server loop.

@item userflags
This bitfield could be used for protocol specific information. You can use
is for any information.

@item boundary, boundary_size
If you are going to write a packet oriented protocol server you can use
the default_check_request method to parse packets. These two properties
describe the packet delimiter.

@item send_buffer, send_buffer_size, send_buffer_fill
This is the outgoing data for a client connection object.

@item recv_buffer, recv_buffer_size, recv_buffer_fill
Within the receive buffer all incoming data for a connection object is 
stored. This buffer is at least used for the client detection callback.

@item read_socket
This callback gets called whenever data is available on the socket.
Normally, this is set to a default function which reads all available
data from the socket and feeds it to check_request, but specific
sockets may need another policy.

@item write_socket
This routine is called when data is is valid in the output buffer
and the socket gets available for writing.  Normally, this simply
writes as much data as possible to the socket and removes it from
the send buffer.

@item disconnected_socket
This gets called whenever the socket is lost for some external reason.

@item kicked_socket
We call this whenever the socket gets closed by us.

@item check_request
This gets called whenever data was read from the socket.
Its purpose is to check whether a complete request was read, and
if it was, it should be handled and removed from the input buffer.

@item handle_request
This gets called when the check_request got a valid packet. The request
arguments contains the actual packet and the second argument is the
length of this packet including the packet delimiter.

@item idle_func
This callback gets called from the periodic task scheduler. Whenever
idle_counter (see below) is non-zero, it is decremented and
idle_func gets called when it drops to zero. idle_func can reset
idle_counter to some value and thus can re-schedule itself for a
later task.
 
@item idle_counter
Counter for calls to idle_func.

@item data
Miscellaneous field. Listener keeps array of server instances here.
This array is NULL terminated.

@item cfg
When the final protocol detection in default_detect_proto
has been done cfg should get the actual configuration hash.

@end table

@subsection Using Co-Servers

Co-Servers are designed to complete blocking tasks. There are several
Co-Servers implemented. These are the dns, reverse dns and ident Co-Server.
If you want to use these you have to @code{#include "coserver/coserver.h"}. 
Secondly you need to implement the callback which gets called when a 
Co-Server completed its task. This routine must be a 
@code{coserver_handle_result_t}. The first
argument is the argument you specified yourself invoking the request and the
second argument is the actual Co-Server result. This might be NULL if the
request could not be fulfilled. To invoke a Co-Server request you use one
of the coserver_* macros. The foo server uses the reverse dns Co-Server to
identify the host name of the remote client.

@node Existing Servers, ,Writing Servers, Server
@section Existing Servers

@menu
* Chat Server::                 Chat Server (aWCS, textSure) description
* HTTP Server::                 Integrated Web Server description
* IRC Server::                  EFNet IRC Server
* Control Protocol Server::     Serveez control center
* Foo Server::                  Example server implementation
@end menu

@node Chat Server, HTTP Server, , Existing Servers
@subsection Chat Server

@subsubsection General description

The whole Serveez package was originally written by Martin Grabmueller for
a fast C backend for a chat system (now called textSure). This can be
found at @uref{http://www.textsure.net/}. The server implements two kinds
of protocols, one for the master server which should do all the 
administrative stuff and the second for the chat clients. Basically the 
chat server is a simple multicast unit.

@subsubsection Specification of the Slave/Master server protocol of aWCS

@table @asis

@item Master server
The first client that connects and sends an aWCS initialize message
(see below) becomes the master server.
When the master server disconnects, all clients get kicked.

@item Other clients
All other clients have to send the aWCS client initialize message,
which is the string "aWCS\0" (note the final NUL character, which is
part of the message). Messages received from those clients are simply
sent to the master server with the client number of the sender
prefixed (see `Messages from clients').

@item Message format
A request consists of a sequence of characters terminated with the
NUL character '\0'.

@item Messages from clients
All messages from clients are routed to the master server, but
modified in such a way that 4 digits and one space precede the
original message. These 4 digits are the (decimal) client's id
right-padded with zeroes.

@item Messages from the master server
Messages that come from the master server must have the following
format:

The first character is one of the following and has a special meaning:

@multitable @columnfractions .15 .85
@item character
@tab meaning
@item 0
@tab Send message to all clients.
@item 1
@tab Send message to the clients denoted in the message.
@item 2
@tab Report status to the master server.
@item 3
@tab Kick the clients denoted in the message.
@item 4
@tab Turn off flood protection for the clients in the message.
@item 5
@tab Turn on flood protection for the clients in the message.
@item 6
@tab Initialization message.
@end multitable

Those special characters are followed by a single space.

Messages which require additional parameters (multicast for example)
carry these parameters after the space in a comma seperated list of
client ids in the above format.  The client id list is terminated
by the \0 character terminating the request (if no parameters follow)
or by a single space (if parameters follow).  Note that in comma
separated lists, no spaces are allowed.

@example
Example:

0 Hallo Welt\0
  - Send "Hallo Welt\0" to all clients except the master server.

1 0001,0004,0006 Gruezi!\0
  - Send "Gruezi\0" to the clients 1, 4 and 6.

2 \0
  - Send status data back to the master server.

3 0003,0004\0
  - Kicks clients 3 and 4.

4 0004,0016\0
  - Turn off flood protection for clients 4 and 16.

5 0001,005\0
  - Turn on flood protection for clients 1 and 5.

6 \0
  - Initialize data structures and accept the connection as the
    master server.

@end example

@item Status messages for the master server
The low level server posts messages to the master server on several
occasions, for example when clients connect, disconnect etc.

Status messages have the same format as other client messages for the
master server.  The client number in the message is 0000, followed by a
space, the status message type and additional parameters.

@multitable @columnfractions .08 .4 .52
@item Type
@tab Description
@tab Parameter
@item 0
@tab Client has connected.
@tab Client id, client IP number:port
@item 1
@tab Client has disconnected.
@tab Client id, error code
@item 2
@tab Client got kicked.
@tab Client id, kick reason
@item 3
@tab Low level server is alive.
@tab 42
@item 4
@tab Notify time elapsed.
@tab 42
@end multitable

@multitable @columnfractions .2 .8
@item Error code
@tab Description
@item 0
@tab Success
@item 1
@tab Client closed connection
@end multitable

@multitable @columnfractions .2 .8
@item Kick reason
@tab Description
@item 0
@tab Flooding
@item 1
@tab Output buffer overflow
@end multitable

@end table

@subsubsection Configuration

@table @asis

@item netport
The @code{netport} parameter is the default network port configuration
where you can specify the network port and IP address.

@item fsport
This parameter could be used to specify two named pipes as connection
device. This is thought for a local installations of the master server
and Serveez.

@end table

@node HTTP Server, IRC Server, Chat Server, Existing Servers
@subsection HTTP Server

@subsubsection General description

The actual reason for writing this server was the need of an additional
web server when using the chat system because the chat client is a web
applet which can only connect to servers where the original html document
with the applet tag came from. Thus you would have need for a standalone
web server on the same machine where Serveez is running... except Serveez
would serve these documents too.

The integrated HTTP server was originally thought to be a simple but fast
document server. But now it can even execute CGI scripts. Both the methods
GET and POST are full featured. Additionally it produces directory listings
when no standard document file (e.g. @file{index.html}) has been found
at the requested document node. Furthermore it implements a file cache for
speeding up repetitive HTTP request.

@subsubsection Configuration

The following options can be set within the configuration file.

@table @asis

@item netport
This is the TCP port configuration hash wherein you can set the IP address
this server should be bind to and the port the server is listening.

@item indexfile
The @code{indexfile} parameter is the default file served by the HTTP 
server when the user does not specify a file but a document node
(e.g. @uref{http://www.textsure.net/}).

@item docs
The @code{docs} parameter is the document root where the server finds its
web documents.

@item cgiurl
This parameter is the first part of the URL the HTTP server identifies a
CGI request. For instance if you specify here @file{/cgi-bin} and the
user requests @uref{http://www.textsure.net/cgi-bin/test.pl} then the
HTTP server tries to execute the program @file{test.pl} within the
@code{cgidir} (see below) and pipes its output to the user.

@item cgidir
The @code{cgidir} is the CGI document root.

@item cache-size
Here you might specify a maximum file size for documents which could be
stored within the HTTP file cache.

@item cache-entries
This parameter specifies the maximum amount of HTTP file cache entries
(files). When you instanciate more than one HTTP server the biggest value
wins. This is why the HTTP file cache is shared by all HTTP servers.

@item timeout
The @code{timeout} value is the amount of time in seconds after which 
a kept alive connection (this is a HTTP/1.1 feature) will be closed when
this connection has been idle.

@item keepalive
On one KeepAlive-connection can be served @code{keepalive} documents 
at all. Then the connection will be closed.

@item default-type
The @code{default-type} is the default content type the HTTP server
assumes if it can not identify a served file by the @code{types} hash
and the @code{type-file} (see below).

@item type-file
This should be a file like the @file{/etc/mime.types} on Linux systems.

@item types
If you want to specify special content types do it here. This parameter
is a has associating file suffixes with HTTP content types.

@end table

@node IRC Server, Control Protocol Server, HTTP Server, Existing Servers
@subsection IRC Server

@node Control Protocol Server, Foo Server, IRC Server, Existing Servers
@subsection Control Protocol Server

@subsubsection General description

Serveez implements something like a telnet protocol for administrating 
purposes. You just need to start a telnet session like:
@example
$ telnet www.textsure.net 42420
@end example
After pressing @key{RET} you will be asked for a password which you 
might setup passing the Serveez the -P argument. @xref{Using Serveez}.

@subsubsection Commands

@table @samp

@item help
This command will give you a very short help screen of all available
commands.

@item quit
Closes the connection to the server.

@item restart ident
Restarts the internal ident Co-Server. This is useful if you just want
to start a new one if it has died.

@item restart dns
Restarts an internal dns lookup server.

@item restart reverse dns
Restarts an internal reverse dns lookup server.


@item killall
This might be useful if Serveez seems to be unstable but you do not
want to restart it. With @samp{killall} you disconnect all network connections
except the control protocol connections.

@item kill id NUM
Disconnect a specific connection.

@item stat
General statistics.

@item stat id NUM
Show statistics about a specific connection.

@item stat con
Connection statistics.

@item stat all
Short connection statistics.

@item stat cache
HTTP cache statistics. This command produces an output something like the 
following where @samp{File} is the short name of the cache entry, 
@samp{Size} the cache size, @samp{Usage} the amount of connections 
currently using this entry, @samp{Hits} the amount of cache hits, 
@samp{Recent} the cache strategy flag (newer entries have larger numbers) 
and @samp{Ready} is the current state of the cache entry.

@item kill cache
Reinitialize the HTTP file cache.

@end table

@subsubsection Configuration

@node Foo Server, , Control Protocol Server, Existing Servers
@subsection Foo Server

The Foo Server is a simple example on how to write internet protocol
servers with Serveez. @xref{Writing Servers}.

@node Co-Server, Porting issues, Server, Top
@chapter Co-Server

@menu
* What are Co-Servers::         The use of Co-Servers in Serveez
* Writing Co-Servers::          How to write Co-Servers with Serveez
* Existing Co-Servers::         What kind of Co-Servers already exist ?
@end menu

@node What are Co-Servers, Writing Co-Servers, , Co-Server
@section What are Co-Servers

If it is necessary to complete blocking tasks in Serveez you have 
to use Co-Servers. The actual implementation in Unices is a process and in
Win32 systems it is realized by a thread.

@node Writing Co-Servers, Existing Co-Servers, What are Co-Servers, Co-Server
@section Writing Co-Servers

@subsection Making and configuring preperations

First you have yo change into the @file{src/coserver/} directory of the 
Serveez package. Then edit the @file{Makefile.am} and add your 
header and implementation file to the @code{libcoserver_a_SOURCES}
variable there.

@subsection Co-Server header file

You must define the Co-Server handle routine here. This callback
gets the input buffer argument and delivers the output buffer result.
Both of these buffers are supposed to be lines separated by a @samp{\n}.

@subsection Co-Server implementation file

Here you need to @code{#include "coserver.h"} and implement the Co-Server 
handle routine defined in the Co-Server header file. This could be any blocking
system call. On successful completion you can return the result or NULL on
errors. The input and output buffers are plain strings and can have any
format with one exception. Because the Co-Servers communicate via a line
protocol with Serveez these buffers must not contain @samp{\n} (0x0d).

@subsection Make your Co-Server available in Serveez

For this you have to edit @file{coserver.h} and @file{coserver.c} in the
@file{src/coserver/} directory. In the header file you have to define a 
further COSERVER_* id and set the MAX_COSERVER_TYPES define to the 
apropiate value. Then you should define a further coserver_* macro in the 
same file.

In @file{coserver.c} you have to implement the coserver_* macro. This macro
takes three arguments. The first is always specific to your Co-Server and is
used to create the actual request string. Then follows the result callback
routine, and an optional argument for this callback. The latter two are
simply passed to the @code{coserver_send_request} routine. This routine 
takes four arguments at all where the first is the previously defined 
COSERVER_* id and the second is the input buffer for the coserver handle 
routine without the trailing @samp{\n}.

Then you need to add your Co-Server to the @code{int_coserver_type} array
specifying the COSERVER_* id, the Co-Server description, the Co-Server
handle routine discussed above, the amount of Co-Server instances to be
created and an optional initialization routine.

@node Existing Co-Servers, , Writing Co-Servers, Co-Server
@section Existing Co-Servers

@subsection Identification (Ident) Co-Server

@subsection Domain Name Server (DNS) Co-Server

@subsection Reverse Domain Name Server (reverse DNS) Co-Server

@node Porting issues, , Co-Server, Top
@chapter Porting issues

Serveez was always designed with an eye on maximum portability. Autoconf 
and Automake have done a great job at this. A lot of @code{#define}s help
to work around some of the different unices oddities. Have a look at
@file{config.h} for a complete list of all these conditionals.

The most doubtful might be the Win32 port. There are two different targets.
Where the @code{__MINGW32__} port refers to a native Win32 port. The home
of the team is @uref{http://www.mingw.org/}. The port to the
@code{__CYGWIN__} target always depends on the unix emulation layer DLL
@file{cygwin1.dll}. Both ports are more or less advanced at this time, but
for performance reasons it is always better to chose native Win32.

Now follows the list on which operating systems and architectures
Serveez has been build and tested successfully.

@itemize @bullet

@item FreeBSD 3.3 on Intel
@item FreeBSD 4.0 on Intel
@item FreeBSD 4.0 on Alpha
@item Linux 2.x.x on Intel
@item Linux 2.x.x on Alpha
@item Solaris 2.6, 2.7 on Sparc 32, Sparc 64
@item SunOS 5.6 on Intel
@item AIX 4.3 on RS6000
@item Windows 95 on Intel
@item Windows 98 on Intel
@item Windows Millenium Edition on Intel
@item Windows NT 4.0 on Intel
@item IRIX 6.x on MIPS
@item Tru64/OSF1 UNIX V4.0 (former Digital UNIX) on Alpha
@item Tru64/OSF1 UNIX V5.0 (former Digital UNIX) on Alpha

@end itemize

@contents
@bye
