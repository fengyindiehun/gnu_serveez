\input texinfo
@c %**start of header
@setfilename serveez.info
@settitle Serveez Documention
@c %** end of header

@set VERSION 0.0.18

@titlepage
@title Serveez
@subtitle Documentation
@subtitle Version @value{VERSION}
@author Stefan Jahn
@author Raimund Jacob
@page
@vskip 0pt plus 1filll

Copyright @copyright{} 2000 Stefan Jahn @email{stefan@@lkcc.org}@*
Copyright @copyright{} 2000 Raimund Jacob @email{raimi@@lkcc.org}@*
Copyright @copyright{} 1999 Martin Grabmueller @email{mgrabmue@@cs.tu-berlin.de}@*

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1
or any later version published by the Free Software Foundation.
A copy of the license is included in the section entitled "GNU
Free Documentation License".

@end titlepage

@node Top, Introduction, (dir), (dir)

@menu
* Introduction::        Introduction to Serveez
* Using Serveez::       Startup and command line options
* Concept::             Conceptional thoughts
* Server::              Server implementation
* Co-Server::           Co-Server implementation
* Porting issues::      Support of different platforms and operating systems
@end menu

@node Introduction, Using Serveez, Top, Top
@chapter Introduction

Serveez is a server framework. It provides routines and help for
implementing IP based servers (currently TCP and UDP). We think it is
worth the effort because many people need server functionality within
their applications. However, many people experience problems with select()-
or poll()-loops and non-blocking operations.
This application demonstrates various aspects of advanced network
programming in a portable manner. It is known to compile and run on
32 bit and 64 bit Un*x flavours as well as on M$ Windows (9x/NT/2000).
You can use it for implementing your own servers or for understanding how
certain network services and operations work.
The package includes a number of servers that work already: a HTTP server,
an IRC server, a Gnutella spider and some others. One of the highlights is
that you can run all protocols on the same port. The application itself is
single threaded but it uses helper processes for concurrent name resolution
and ident lookups.

@node Using Serveez, Concept, Introduction, Top
@chapter Using Serveez

@section Starting Serveez

To start Serveez simply type @samp{serveez} at your command line prompt
and press @key{RET}. This will invoke the @file{serveez.[exe]} which will
read its configuration from a file called @file{serveez.cfg} in the current
directory and run the server loop afterwards. Press @key{^C} to abort the
execution of this program.

@section Command line options

@table @code
@item -h, --help
Display this help and exit.
@item -V, --version
Display version information and exit.
@item -i, --iflist
List local network interfaces and exit.
@item -f, --file=FILENAME
File to use as configuration file (serveez.cfg).
@item -v, --verbose=LEVEL
Set level of logging verbosity.
@item -l, --log-file=FILENAME
Use FILENAME for logging (default is stderr).
@item -P, --password=STRING
Set the password for control connections.
@item -m, --max-sockets=COUNT
Set the maximum number of socket descriptors.
@end table

@section Configuring Serveez

As noted above Serveez is configured via a configuration file which is
by default @file{serveez.cfg} and can be set by passing the -f command
line argument. We are using the Scheme dialect called Sizzle for this
configuration file. This package is maintained by Martin Grabmueller
(@email{mgrabmue@@cs.tu-berlin.de}). Because we do not want you to learn
too much about that computer language we delivered an example 
configuration file in the @file{doc/} directory.

Generally you can determine special variables in this file and you have
to instanciated the servers you actually want to run. The following
example shows how do you setup a server whose short name is @samp{xxx}.
The @samp{?} is the instance number of that server. You can define
more than one @samp{xxx-server}, of course. The body of such a server
hash contains key value pairs which set up this specific server.
@xref{Existing Servers}, for more information about these pairs.

@example
@group
(define xxx-server? '#@{
                        "key" => value
                      @})
@end group
@end example

When we are refer to @samp{port configuration}s this is a special hash
determining a network or filesystem configuration. This structure got
the following layout:

@example
@group
"NameOfPortCfg" => #@{
                       ;; one of those possibilities
                       "proto"    => "tcp" || "udp" || "pipe"
                       ;; tcp or udp port number
                       "port"     => 42420
                       ;; ip address to bind the server to
                       "local-ip" => "*" || xxx.xxx.xxx.xxx
                       ;; receiving pipe
                       "inpipe"   => "MyRecvPipe"
                       ;; sending pipe
                       "outpipe"  => "MySendPipe"
                    @}
@end group
@end example

@node Concept, Server, Using Serveez, Top
@chapter Concept

@section I/O Strategy
Serveez's I/O strategy is the traditional @code{select()} method. It 
is serving many clients in one server thread. This is done by setting to 
nonblocking mode on all network handles, and use @code{select()} to tell 
which network handle has data waiting. This is the traditional favorite. 

An important bottleneck in this method is that @code{read()} or 
@code{sendfile()} from disk blocks if the page is not in core at the 
moment, setting nonblocking mode on a disk file handle has no effect. 
Same thing goes for memory-mapped disk files. The first time a server
needs disk I/O, its process blocks, all clients must wait, and that 
raw nonthreaded performance goes to waste. 

Unfortunately, @code{select()} is limited to @code{FD_SETSIZE} handles. 
This limit is compiled in to the standard library and user programs. 
Nevertheless Serveez is able to serve about one thousand and more 
clients on Linux, a hundred on Win95 and about five hundred on 
WinNT systems.

We chose this method anyway because it seems the most portable. Either in
most Unices and Win32 this method is implemented.

An alternative method to multiplex client network connections is 
@code{poll()}. When detected by @file{configure} Serveez is using it. This
will work around the builtin (g)libs's @code{select()} file descriptor
limit.

@section Limits on open filehandles
@table @asis
@item Any Unix
The limits set by @code{ulimit ()} or @code{setrlimit ()}.
@item Solaris
See the Solaris FAQ, question 3.45.
@item FreeBSD 
Use sysctl -w kern.maxfiles=nnnn to raise limit.
@item Linux
See Bodo Bauer's /proc documentation. On current 2.2.x kernels, 
@example
echo 32768 > /proc/sys/fs/file-max
echo 65536 > /proc/sys/fs/inode-max
@end example
increases the system limit on open files, and 
@example
ulimit -n 32768
@end example
increases the current process' limit. I verified that a process on 
Red Hat 6.0 (2.2.5 or so plus patches) can open at least 31000 file 
descriptors this way. Another fellow has verified that a process on 
2.2.12 can open at least 90000 file descriptors this way (with 
appropriate limits). The upper bound seems to be available memory. 
@end table

@node Server, Co-Server, Concept, Top
@chapter Server

@menu
* Introduction to Servers::     Protocol servers in Serveez
* Writing Servers::             How to write internet protocol servers
* Existing Servers::            Which kind of servers do we have already ?
@end menu

@node Introduction to Servers, Writing Servers, Server, Server
@section Introduction to Servers

This package includes a kind of server server. It allows different 
protocol servers to listen on various TCP/IP or UDP ports and server 
instanciating. Thus it is possible to to have different servers on the 
same port.

This chapter covers all questions about how to write your own internet
protocol server with little help of this package. Most of the usual tasks of
such a server have got their generic solutions which could be shadowed by 
your own routines. There are some examples within this package showing the
possibilities and one very simple example how to implement such a server.

The foo server does not do anything at all and is of no use actually
but could be a basis for a new protocol server. We are now going to describe
how this specific server works. Eventually the reader might have got an idea
what is going on here.

@node Writing Servers, Existing Servers, Introduction to Servers, Server
@section Writing Servers

@subsection Making and configuring preperations

Serveez is configured and build via automake and autoconf. That
is why you are not supposed to write your own Makefiles but simplified
@file{Makefile.am}s. Automake will automatically generate dependencies and
compiler and linker command lines. Here are the steps you basically need 
to follow:

@itemize @bullet
@item
Change to the @file{src/} directory in the source tree.

@item
Edit the @file{Makefile.am}. Add your sub directory name and library name
which you are going to create.

@item
Now create the sub directory and change into it.

@item
You need to create a new @file{Makefile.am} therein. If you want to have
this file @file{configure}d you need to add a further line to the 
@code{AC_OUTPUT()} statement in @file{configure.in}.
You have to put at least the following into the newly created
@file{Makefile.am}:

@example
@group
noinst_LIBRARIES = libfoo.a
AM_CPPFLAGS = -I..
CLEANFILES = *~
libfoo_a_SOURCES = foo-proto.h foo-proto.c
@end group
@end example

@item
Just have a look at all the other server directories. For more information
about automake read the info pages.

@end itemize

@subsection Server header file @file{foo-proto.h}

This file contains at least your servers configuration structure and
some global definitions of server routines which must be available outside.
Furthermore it contains the global definition of your server definition. The
foo server implements all kinds of configurations items which could be
integers, string arrays, strings, integer arrays, port configurations and
hashes. Every thing within this configuration will be configurable within
the configuration file later.

@subsection Server implementation file @file{foo-proto.c}

If you want to define default values for your configuration you have
to define it somewhere and put it into the default configuration structure.
This structure will be used to instanciate your server. In this case we 
called it simply `mycfg'.

In order to associate the configurations items in a server 
configuration to keywords within the configuration file you have to define a
array of key-value-pairs. This is done in the `foo_config_prototype' field.
There are several macros which make different associations. These are the
REGISTER_* macros which take three arguments. The first argument is the
keyword which will occur in the configuration file, the second is the
associated item in your default configuration structure and the last argument
specifies if this item is defaultable or not.

@subsection Server definition

The server definition is the representation of your server object 
which will be instanciatable. You have to put in this structure a long and
a short description of your server. The short name will be used to instanciate
the server object via the configuration file. You can instanciate it by
writing @code{(define foo-server1 '#@{ ... @})} where @code{foo} is your 
servers short name. Moreover you have to put there the server 
callbacks which will be described later and the configuration 
associations described above.

@subsection Server callbacks

There are several callback routines, which get called in order to 
instanciate the server and for describing the actual behaviour of your server.
Here is the description of all of these.

@table @asis
@item global initializer (optional)
This callback is executed once for initializing the server. Here you can
initialize data or whatever shared by all instances of your server. For
instance the http server would load the mime type file here. The foo
server creates its default hash property because a hash cannot be
statically initialized.

@item global finalizer (optional)
If you want to free shared resources which were possibly allocated within
the global initializer you can do so here. The foo server frees its
default hash previouly allocated in the global initializer.

@item instance finalizer (optional)
The server instance finalizer gets its instance representation as argument.
You have to free all resources used by this server instance. The foo server
destroys its hash if it was not the default hash which gets freed within
the global finalizer.

@item instance initializer (mandatory)
Within this routine you can initialize all you might need for one instance
of your server. Secondly you have to bind this instance to some port
configuration. In most cases you want to have this port configuration
accessable via the configuration file. Therefore you have to 
REGISTER_PORTCFG () in your servers configuration definition. The port
configuration is then part of your servers instance configuration
structure. The foo server prints its whole configuration just for debugging
purposes. It simply shows how configurable items from the configuration
file fall to the server instance configuration. If you are going to plan
that one server instance listens on different ports you can do so.

@item protocol detection (mandatory)
Because it is possible to have more than one server listening on one 
network port we are going to detect the type of client which is connecting
to this port. The foo servers checks if the first five bytes the client
was sending is identifying it as a foo client. This routine is getting
two arguments where the first one is a pointer to this servers instance
configuration and the second is the client socket object containing all
information of the client connection. This structure is describe a bit
later. Be patient. For successful client detection return non-zero 
otherwise zero.

@item connect socket (mandatory)
If the client detection signaled success this routine is called to assign
the client connection to this servers instance. The arguments are just
the same as in the detection routine. In this callback you can assign
all the connection specific callbacks for your server and do some initial
things. The foo server sets the @code{check_request} callback to the 
@code{default_check_request} which is using the packet delimiter 
information to find whole packets. When a client sent such a packet the 
@code{handle_request} callback is executed. That is why the foo server 
assigns the @code{handle_request} method.

@item client info (optional)
If this callback is given the control protocol 
(@xref{Control Protocol Server}.) can give information about a specific
client if requested with @samp{stat id NUM}. The first arguments given
is the server configuration hash and the second one the clients socket
structure. You must return a static single line character string.

@item server info (optional)
When listing the server instances via @samp{stat all} within the control
protocol (@xref{Control Protocol Server}.) the returned character string
which might be multiline seperated by @code{\r\n} (no trailing seperator).
Usually you will return all the server configuration information.

@item timer (optional)
If this callback is non-NULL it is called whenever there is some time 
left. It gets the server instance itself as argument. Actually it gets
called every second.

@item handle request (mandatory for udp servers)
The arguments to this callback specify a whole packet, its address and the
length. When implementing a udp server you need to return non-zero if your
server could process the packet and zero otherwise. Thus it is possible that
there are multiple udp servers on a single port.
@end table

@subsection Make your server available

You distribute your server by editing the @file{server.c} file in the
@file{src/} directory. There you have to include the the servers header 
file and add the server definition to the @code{all_server_definition} array.

@subsection More detailed description of the callback system and structures

The client connection information is stored within the socket_t 
object. All of the client connection specific callbacks get this object as
first argument. Here follows a decription of the elements of this object.

@table @code
@item id
The socket id is a unique id for a client connection.

@item version
This item validates this socket structure. If you pass the @code{id} and
@code{version} to a Co-Server you can check if the delivered socket 
structure is the original or not within the Co-Server callback.

@item flags
The flag field of the client connection contains informations about the
state of this connection. See @file{socket.h} in the @file{src/} directory 
for more information. Basically this bitfield specifies how this object
is handle by the main server loop.

@item userflags
This bitfield could be used for protocol specific information. You can use
is for any information.

@item boundary, boundary_size
If you are going to write a packet oriented protocol server you can use
the default_check_request method to parse packets. These two properties
describe the packet delimiter.

@item send_buffer, send_buffer_size, send_buffer_fill
This is the outgoing data for a client connection object.

@item recv_buffer, recv_buffer_size, recv_buffer_fill
Within the receive buffer all incoming data for a connection object is 
stored. This buffer is at least used for the client detection callback.

@item read_socket
This callback gets called whenever data is available on the socket.
Normally, this is set to a default function which reads all available
data from the socket and feeds it to check_request, but specific
sockets may need another policy.

@item write_socket
This routine is called when data is is valid in the output buffer
and the socket gets available for writing.  Normally, this simply
writes as much data as possible to the socket and removes it from
the send buffer.

@item disconnected_socket
This gets called whenever the socket is lost for some external reason.

@item kicked_socket
We call this whenever the socket gets closed by us.

@item check_request
This gets called whenever data was read from the socket.
Its purpose is to check whether a complete request was read, and
if it was, it should be handled and removed from the input buffer.

@item handle_request
This gets called when the check_request got a valid packet. The request
arguments contains the actual packet and the second argument is the
length of this packet including the packet delimiter.

@item idle_func
This callback gets called from the periodic task scheduler. Whenever
idle_counter (see below) is non-zero, it is decremented and
idle_func gets called when it drops to zero. idle_func can reset
idle_counter to some value and thus can re-schedule itself for a
later task.
 
@item idle_counter
Counter for calls to @code{idle_func}.

@item data
Miscellaneous field. Listener keeps array of server instances here.
This array is NULL terminated. Some servers store server specific 
information here.

@item cfg
When the final protocol detection in default_detect_proto
has been done cfg should get the actual configuration hash.
@end table

@subsection Using Co-Servers

Co-Servers are designed to complete blocking tasks. There are several
Co-Servers implemented. These are the dns, reverse dns and ident Co-Server.
If you want to use these you have to @code{#include "coserver/coserver.h"}. 
Secondly you need to implement the callback which gets called when a 
Co-Server completed its task. This routine must be a 
@code{coserver_handle_result_t}. The first
argument is the argument you specified yourself invoking the request and the
second argument is the actual Co-Server result. This might be NULL if the
request could not be fulfilled. To invoke a Co-Server request you use one
of the coserver_* macros. The foo server uses the reverse dns Co-Server to
identify the host name of the remote client.

@node Existing Servers,  , Writing Servers, Server
@section Existing Servers

@menu
* Chat Server::                 Chat Server (aWCS, textSure) description
* HTTP Server::                 Integrated Web Server description
* IRC Server::                  EFNet IRC Server
* Control Protocol Server::     Serveez control center
* Foo Server::                  Example server implementation
* Quake III Key Server::        Quake 3 License Key Server description
* Gnutella Spider::             Gnutella Client description
@end menu

@node Chat Server, HTTP Server, Existing Servers, Existing Servers
@subsection Chat Server

@subsubsection General description

The whole Serveez package was originally written by Martin Grabmueller for
a fast C backend for a chat system (now called textSure). This can be
found at @uref{http://www.textsure.net/}. The server implements two kinds
of protocols, one for the master server which should do all the 
administrative stuff and the second for the chat clients. Basically the 
chat server is a simple multicast unit.

@subsubsection Specification of the Slave/Master server protocol of aWCS

@table @asis
@item Master server
The first client that connects and sends an aWCS initialize message
(see below) becomes the master server.
When the master server disconnects, all clients get kicked.

@item Other clients
All other clients have to send the aWCS client initialize message,
which is the string "aWCS\0" (note the final NUL character, which is
part of the message). Messages received from those clients are simply
sent to the master server with the client number of the sender
prefixed (see `Messages from clients').

@item Message format
A request consists of a sequence of characters terminated with the
NUL character '\0'.

@item Messages from clients
All messages from clients are routed to the master server, but
modified in such a way that 4 digits and one space precede the
original message. These 4 digits are the (decimal) client's id
right-padded with zeroes.

@item Messages from the master server
Messages that come from the master server must have the following
format:

The first character is one of the following and has a special meaning:

@multitable @columnfractions .15 .85
@item character
@tab meaning
@item 0
@tab Send message to all clients.
@item 1
@tab Send message to the clients denoted in the message.
@item 2
@tab Report status to the master server.
@item 3
@tab Kick the clients denoted in the message.
@item 4
@tab Turn off flood protection for the clients in the message.
@item 5
@tab Turn on flood protection for the clients in the message.
@item 6
@tab Initialization message.
@end multitable

Those special characters are followed by a single space.

Messages which require additional parameters (multicast for example)
carry these parameters after the space in a comma seperated list of
client ids in the above format.  The client id list is terminated
by the \0 character terminating the request (if no parameters follow)
or by a single space (if parameters follow).  Note that in comma
separated lists, no spaces are allowed.

@example
@group
Example:

0 Hallo Welt\0
  - Send "Hallo Welt\0" to all clients except the 
    master server.

1 0001,0004,0006 Gruezi!\0
  - Send "Gruezi\0" to the clients 1, 4 and 6.

2 \0
  - Send status data back to the master server.

3 0003,0004\0
  - Kicks clients 3 and 4.

4 0004,0016\0
  - Turn off flood protection for clients 4 and 16.

5 0001,005\0
  - Turn on flood protection for clients 1 and 5.

6 \0
  - Initialize data structures and accept the 
    connection as the master server.
@end group
@end example

@item Status messages for the master server
The low level server posts messages to the master server on several
occasions, for example when clients connect, disconnect etc.

Status messages have the same format as other client messages for the
master server.  The client number in the message is 0000, followed by a
space, the status message type and additional parameters.

@group
@multitable @columnfractions .08 .4 .52
@item Type
@tab Description
@tab Parameter
@item 0
@tab Client has connected.
@tab Client id, client IP number:port
@item 1
@tab Client has disconnected.
@tab Client id, error code
@item 2
@tab Client got kicked.
@tab Client id, kick reason
@item 3
@tab Low level server is alive.
@tab 42
@item 4
@tab Notify time elapsed.
@tab 42
@end multitable
@end group

@group
@multitable @columnfractions .2 .8
@item Error code
@tab Description
@item 0
@tab Success
@item 1
@tab Client closed connection
@end multitable
@end group

@group
@multitable @columnfractions .2 .8
@item Kick reason
@tab Description
@item 0
@tab Flooding
@item 1
@tab Output buffer overflow
@end multitable
@end group

@end table

@subsubsection Configuration

@table @asis
@item netport
The @code{netport} parameter is the default network port configuration
where you can specify the network port and IP address.

@item fsport
This parameter could be used to specify two named pipes as connection
device. This is thought for a local installations of the master server
and Serveez.
@end table

@node HTTP Server, IRC Server, Chat Server, Existing Servers
@subsection HTTP Server

@subsubsection General description

The actual reason for writing this server was the need of an additional
web server when using the chat system because the chat client is a web
applet which can only connect to servers where the original html document
with the applet tag came from. Thus you would have need for a standalone
web server on the same machine where Serveez is running... except Serveez
would serve these documents too.

The integrated HTTP server was originally thought to be a simple but fast
document server. But now it can even execute CGI scripts. Both the methods
GET and POST are full featured, HEAD too. Additionally it produces 
directory listings when no standard document file 
(e.g. @file{index.html}) has been found at the requested document node. 
Furthermore it implements a file cache for speeding up repetitive 
HTTP request.

In comparison to other web server projects like Apache and Roxen this
web server is really fast. Comparative benchmarks will follow.

@subsubsection Configuration

The following options can be set within the configuration file.

@table @asis
@item netport
This is the TCP or UDP port configuration hash wherein you can set the 
IP address this server should be bind to and the port the server is 
listening.

@item indexfile
The @code{indexfile} parameter is the default file served by the HTTP 
server when the user does not specify a file but a document node
(e.g. @uref{http://www.textsure.net/}).

@item docs
The @code{docs} parameter is the document root where the server finds its
web documents.

@item cgiurl
This parameter is the first part of the URL the HTTP server identifies a
CGI request. For instance if you specify here @file{/cgi-bin} and the
user requests @uref{http://www.textsure.net/cgi-bin/test.pl} then the
HTTP server tries to execute the program @file{test.pl} within the
@code{cgidir} (see below) and pipes its output to the user.

@item cgidir
The @code{cgidir} is the CGI document root.

@item cache-size
Here you might specify a maximum file size for documents which could be
stored within the HTTP file cache.

@item cache-entries
This parameter specifies the maximum amount of HTTP file cache entries
(files). When you instanciate more than one HTTP server the biggest value
wins. This is why the HTTP file cache is shared by all HTTP servers.

@item timeout
The @code{timeout} value is the amount of time in seconds after which 
a kept alive connection (this is a HTTP/1.1 feature) will be closed when
this connection has been idle.

@item keepalive
On one KeepAlive-connection can be served @code{keepalive} documents 
at all. Then the connection will be closed.

@item default-type
The @code{default-type} is the default content type the HTTP server
assumes if it can not identify a served file by the @code{types} hash
and the @code{type-file} (see below).

@item type-file
This should be a file like the @file{/etc/mime.types} on Linux systems.

@item types
If you want to specify special content types do it here. This parameter
is a has associating file suffixes with HTTP content types.
@end table

@node IRC Server, Control Protocol Server, HTTP Server, Existing Servers
@subsection IRC Server

@subsubsection General description

The integrated IRC server is intended to be compatible with the EFNet.
Because there are no good possibilties to test this in real live it is
still under heavy construction but could be used as a standalone server
anyway.

IRC itself is a teleconferencing system, which (through the use of
the client-server model) is well-suited to running on many machines
in a distributed fashion. A typical setup involves a single process
(the server) forming a central point for clients (or other servers)
to connect to, performing the required message delivery/multiplexing
and other functions.

The server forms the backbone of IRC, providing a point to which
clients may connect to to talk to each other, and a point for other
servers to connect to, forming an IRC network. The only network
configuration allowed for IRC servers is that of a spanning tree
where each server acts as a central node for the rest of the
net it sees.

@subsubsection Configuration

As all the servers described in this section the IRC server is also
instanciated and configured in the configuration file. The following
table shows the provided configuration keys. Most of the configuration
items are similiar to those of an Hybrid IRC server.

@table @samp
@item port
The @samp{port} parameter is, as in all the server configurations, the
port configuration for this server, specifying IP address and the TCP/IP 
port the server should listen on.

@item MOTD-file
When a user initially joins it will get this file's content as the
message of the day comment. When changing on disk the server will notice
that and reload the file automatically.

@item INFO-file
The @samp{INFO-file}s content gets displayed when the user commits the
/INFO command.

@item tsdelta
This value is the timestamp delta value to UTC in seconds.

@item admininfo, email, location1, location2
Some administrative information delivered on the /ADMIN command.

@item M-line (Mandatory)
This IRC server's configuration. The format of this line is:
@example
@group
":" VirtualHostName
":" OptionalBindAddress (real hostname)
":" TextName
":" Port
@end group
@end example

@item A-line (Mandatory)
The administrative info, printed by the /ADMIN command.
@example
@group
":" administrative info (department, university)
":" the server's geographical location
":" email address for a person responsible for the irc server
@end group
@end example

@item Y-lines (Suggested)
The connection classes.
@example
@group
":" class number (higher numbers refer to a higher priority)
":" ping frequency (in seconds)
":" connect frequency in seconds for servers, 0 for client class
":" maximum number of links in this class 
":" send queue size
@end group
@end example

@item I-lines (Mandatory)
Authorization of clients, wildcards permitted, a valid client is matched
@email{user@@ip} OR @email{user@@host}.
@example
@group
":" user@@ip, you can specify @samp{NOMATCH} here to 
    force matching user@@host
":" password (optional)
":" user@@host
":" password (optional)
":" connection class number (YLine)
@end group
@end example

@item O-lines (Optional)
Authorize operator, wildcards allowed.
@example
@group
":" user@@host, user@@ forces checking ident
":" password
":" nick
@end group
@end example

@item o-lines (Optional)
Authorize local operator, see above at the O lines for a description.
@example
@group
@end group
@end example

@item C-lines (Networked)
List of servers to connect to.
Note: C and N lines can also use the user@@ combination in order to 
check specific users (ident) starting servers. C and N lines are 
usually given in pairs.
@example
@group
":" host name
":" password
":" server name (virtual)
":" port (if not given we will not connect)
":" connection class number (YLine)
@end group
@end example

@item N-lines (Networked)
Server which may connect.
@example
@group
":" host name
":" password
":" server name (virtual host name)
":" password
":" how many components of your own server's name to 
    strip off the front and be replaced with a *.
":" connection class number (YLine)
@end group
@end example

@item K-lines (Optional)
Kill user, wildcards allowed.
@example
@group
":" host
":" time of day
":" user
@end group
@end example

@end table

@node Control Protocol Server, Foo Server, IRC Server, Existing Servers
@subsection Control Protocol Server

@subsubsection General description

Serveez implements something like a telnet protocol for administrating 
purposes. You just need to start a telnet session like:
@example
$ telnet www.textsure.net 42420
@end example
After pressing @key{RET} you will be asked for a password which you 
might setup passing the Serveez the -P argument. @xref{Using Serveez}.

@subsubsection Commands

@table @samp
@item help
This command will give you a very short help screen of all available
commands within the control protcol.

@item quit
This command closes the connection to Serveez.

@item restart ident
Restarts the internal ident Co-Server. This is useful if you just want
to start a new one if it has died or otherwise disturbed.

@item restart dns
Restarts an internal dns lookup server.

@item restart reverse dns
Restarts an internal reverse dns lookup server.

@item killall
This might be useful if Serveez seems to be unstable but you do not
want to restart it. With @samp{killall} you disconnect all client
network connections except the control protocol connections.

@item kill id NUM
Disconnects a specific connection identified by its ID. These IDs will
be stated when you type @samp{stat con} (see below).

@item stat
General statistics about Serveez. This will show you some useful
information about the computer Serveez is running on and about the
state of Serveez in general.

@example
@group
@exdent This is serveez version 0.0.17pre running since Sat Jul 15 18:45:58 2000.
@exdent Features  : AWCS HTTP IDENT REVERSE-DNS DNS FLOOD DEBUG IRC CTRL
@exdent Os        : Linux 2.2.10 on i586
@exdent Sys-Load  : user 0.0%, nice 0.0%, sys 1.0%, idle 99.0%
@exdent Proc-Load : user 0.0%, sys 0.0%, child user 0.0%, child sys 0.0%
@exdent 1 connected sockets (hard limit is 200)
@end group
@end example

@item stat id NUM
Show statistics about a specific connection. This will give you all
available information about every connection you specified.
@xref{Writing Servers}, for more information about how to provide these
information.

@item stat con
Connection statistics. This will give a list of all socket structures
within Serveez. If you want more detailed information about specific
connections, Co-Servers or Servers you need to request these information
with @samp{stat id NUM} or @samp{stat all}.

@item stat all
Server and Co-Server instance statistics. This command should list all 
the information about instanciated Servers and Co-Servers. 
@xref{Writing Servers}, for more information about how to provide these
information.

@item stat cache
HTTP cache statistics. This command produces an output something like the 
following where @samp{File} is the short name of the cache entry, 
@samp{Size} the cache size, @samp{Usage} the amount of connections 
currently using this entry, @samp{Hits} the amount of cache hits, 
@samp{Recent} the cache strategy flag (newer entries have larger numbers) 
and @samp{Ready} is the current state of the cache entry.

@example
@group
@exdent File                      Size  Usage  Hits Recent Ready
@exdent zlib-1.1.3-20000531.zip  45393      0     0      1 Yes
@exdent texinfo.tex             200531      0     0      2 Yes
@exdent shayne.txt                2534      0     1      1 Yes

@exdent Total : 248458 byte in 3 cache entries
@end group
@end example
@item kill cache
Reinitialize the HTTP file cache.
@end table

@subsubsection Configuration

@table @asis
@item netport
This option is used to define the port configuration. Here it could be
useful to declare a @samp{local-ip} within this hash when you do not
want people using this protocol from outsides.
@end table

@node Foo Server, Quake III Key Server, Control Protocol Server, Existing Servers
@subsection Foo Server

The Foo Server is a simple example on how to write internet protocol
servers with Serveez. @xref{Writing Servers}.

@node Quake III Key Server, Gnutella Spider, Foo Server, Existing Servers
@subsection Quake III Key Server

@subsubsection Motivation

First of all, this software is probably illegal. Period.

Please buy the game. But you may need this software anyway, because
commercial software developers are narrow minded sometimes.

You just have the choice between LAN and Internet connection when running
the game. But the real choice you have is: LAN in one broadcast domain 
vs. permanent internet connection. This leaves the whole area of 
subnet'ed LANs or inhouse networks, subnet'ed LAN parties or LANs 
interconnected with phonelines. This pissed me off.

@subsubsection Configuration

Run this program on some computer and make the clients think this
computer is a key server. Add following lines to @file{/etc/hosts}
or @file{c:\windows\hosts} :
@example
127.0.0.1       authorize.quake3arena.com
@end example
Replace 127.0.0.1 by the IP address of your server machine. Perhaps 
you want to add some entry for @uref{update.quake3arena.com}, too.
If you have got a complete master server add entries for:
@example
master.quake3world.com
master.quake3arena.com
master3.idsoftware.com
@end example
The configuration of the server knows the following items.
@table @asis
@item netport
This entry should contain @samp{udp} for @samp{proto} and some udp port.
The default port is 27952.

@item echo
The key servers echo reply when authorizing.

@item logfile
All keys the clients send will be logged within this file.
@end table

@node Gnutella Spider, , Quake III Key Server, Existing Servers
@subsection Gnutella Spider

@subsubsection What is it ?
The Gnutella net is some kind of peer-to-peer network which is based on
client programs only. There are no servers. The network itself is formed
by client connections only. Generally the Gnutella network is for sharing
files of any kind.

This Gnutella spider is for seeking the needly in the haystack. Once 
connected to the network it regulary tries to find certain files in there.
It keeps track of all connected clients and tries to reconnect them if
the current connections are lost.

@subsubsection Configuration
The Gnutella spider knows the following configurations items.

@table @asis
@item port
This entry should contain @samp{tcp} for @samp{proto} and some port and
network interface. The default port is 6346. If you want to see the host
catcher list of this Gnutella spider you can connect to this port with 
any WWW browser at @uref{http://localhost:6346/gnutella-net}.

@item hosts
This is the initial host list of the clients the spider tries to connect.
Each list item should be of the format @code{ip:port} (e.g. 
@samp{146.145.85.34:6346}).

@item search
This is the so called needle. Each search line is either a set of 
@key{SPC} delimited tokens where every token must match a search 
reply for downloading it or a kind of wildcard expression including 
@samp{?} and @samp{*}. Search lines are always matched case insensitive.

@item search-limit
This limits how many results the Gnutella spider returns to other people 
searching your files.

@item max-ttl
Every Gnutella packet has got a TTL. This is the maximum TTL allowed for
outgoing packets.

@item ttl
When creating a new Gnutella packet we use this as TTL.

@item download-path
This is where the spider saves needles in.

@item share-path
Here are all the files we share with others. The Gnutella spider will 
recurse into directories. Thus be careful with this option.

@item max-downloads
Maximum amount of concurrent downloads from the network.

@item max-uploads
Maximum amount of concurrent uploads to the network.

@item connection-speed
This is what we send as our connection speed in KBit/s. We also use this
value to throttle down the network transfer rate for file uploads.

@item min-speed
Search for needles on hosts with a minimum speed. Set it to 0 if you do
not care about. This value is in KBit/s, too.

@item file-extensions
If we get replies on search queries we check if the file extension of this
reply matches one of these extensions. Useful extensions are @samp{mp3} and
@samp{mpg}.

@item connections
This is the amount of concurrent connections the Gnutella spider tries
to keep up to the network. The IP addresses and the port information is
taken from the host catcher hash.

@item force-ip
You can force the Gnutella spider to send outgoing ping replies with this
IP as host information. Must be in dotted decimals notation.
@end table

@node Co-Server, Porting issues, Server, Top
@chapter Co-Server

@menu
* What are Co-Servers::         The use of Co-Servers in Serveez
* Writing Co-Servers::          How to write Co-Servers with Serveez
* Existing Co-Servers::         What kind of Co-Servers already exist ?
@end menu

@node What are Co-Servers, Writing Co-Servers, Co-Server, Co-Server
@section What are Co-Servers

If it is necessary to complete blocking tasks in Serveez you have 
to use Co-Servers. The actual implementation in Unices is a process and in
Win32 systems it is realized by a thread.

@node Writing Co-Servers, Existing Co-Servers, What are Co-Servers, Co-Server
@section Writing Co-Servers

@subsection Making and configuring preperations

First you have yo change into the @file{src/coserver/} directory of the 
Serveez package. Then edit the @file{Makefile.am} and add your 
header and implementation file to the @code{libcoserver_a_SOURCES}
variable there.

@subsection Co-Server header file

You must define the Co-Server handle routine here. This callback
gets the input buffer argument and delivers the output buffer result.
Both of these buffers are supposed to be lines separated by a @samp{\n}.

@subsection Co-Server implementation file

Here you need to @code{#include "coserver.h"} and implement the Co-Server 
handle routine defined in the Co-Server header file. This could be any blocking
system call. On successful completion you can return the result or NULL on
errors. The input and output buffers are plain strings and can have any
format with one exception. Because the Co-Servers communicate via a line
protocol with Serveez these buffers must not contain @samp{\n} (0x0d).

@subsection Make your Co-Server available in Serveez

For this you have to edit @file{coserver.h} and @file{coserver.c} in the
@file{src/coserver/} directory. In the header file you have to define a 
further COSERVER_* id and set the MAX_COSERVER_TYPES define to the 
appropiate value. Then you should define a further coserver_* macro in the 
same file.

In @file{coserver.c} you have to implement the coserver_* macro. This macro
takes three arguments. The first is always specific to your Co-Server and is
used to create the actual request string. Then follows the result callback
routine, and an optional argument for this callback. The latter two are
simply passed to the @code{coserver_send_request} routine. This routine 
takes four arguments at all where the first is the previously defined 
COSERVER_* id and the second is the input buffer for the coserver handle 
routine without the trailing @samp{\n}.

Then you need to add your Co-Server to the @code{int_coserver_type} array
specifying the COSERVER_* id, the Co-Server description, the Co-Server
handle routine discussed above, the amount of Co-Server instances to be
created and an optional initialization routine.

@node Existing Co-Servers,  , Writing Co-Servers, Co-Server
@section Existing Co-Servers

@subsection Identification (Ident) Co-Server

The Identification Protocol is briefly documented in RFC1413. It
provides a means to determine the identity of a user of a particular 
TCP connection. Given a TCP port number pair, it returns a character 
string which identifies the owner of that connection on the server's system.

This is a connection based application on TCP. A server listens for
TCP connections on TCP port 113 (decimal). Once a connection is
established, the server reads a line of data which specifies the
connection of interest. If it exists, the system dependent user
identifier of the connection of interest is sent as the reply. The
server may then either shut the connection down or it may continue to
read/respond to multiple queries.

Actually the Ident Co-Server is a client to this kind of service. For
every established network connection you can use this service by calling
the appropiate macro from @file{coserver.h}. But you could also use the
Ident Co-Server as is without this macro. The format of the input buffer
is:

@example
@group
Format:
RemoteAddressInDottedDecimals ":" RemotePort ":" LocalPort

Macro:
coserver_ident (sock, MyIdentCallback, sock->id, sock->version);
@end group
@end example

In this context @code{sock} is of type @code{socket_t} and 
@code{MyIdentCallback} is something like the following example. Both
of the last two (optional) arguments identify a valid socket structure
and @code{user} can be NULL if there is no ident deamon running on the 
foreign machine. The last two argument within the above macro will be the 
last two arguments in the below callback. Thus you will know what kind of 
data the invocation of the callback is related to.

@example
@group
Callback:
int
MyIdentCallback (char *user, int id, int version)
@{
  printf ("Identified user: %s\n", user);
  return 0;
@}
@end group
@end example

@subsection Domain Name Server (DNS) Co-Server

The DNS Co-Server is using @code{gethostbyname()} to translate a given
hostname to the appropiate IP address. The format of the Co-Server input
line and the macro from @file{coserver.h} is shown below. The IRC server is
currently using this Co-Server for resolving its @samp{?-Lines}.
@xref{Existing Servers}, for more information. In the below example 
@code{realhost} is something like @samp{www.textsure.net}.

@example
@group
Format:
RemoteHostname

Macro:
coserver_dns (realhost, irc_connect_server, ircserver, NULL);

Callback:
int
irc_connect_server (char *ip, irc_server_t *server)
@{
  printf ("The ip address is: %s\n", ip);
  return 0;
@}
@end group
@end example

@subsection Reverse Domain Name Server (reverse DNS) Co-Server

As easily guessed from the name this Co-Server is just doing the reverse
as the DNS Co-Server. It translates a given IP address into a hostname
using @code{gethostbyaddr()}. Within the macro the ip address is given
as an @code{unsigned long} in host byte order and the Reverse DNS 
Co-Server itself takes something like @samp{192.168.2.1}.

@example
@group
Format:
RemoteAddressInDottedDecimals

Macro:
coserver_reverse (addr, MyReverseCallback, sock->id, sock->version);

Callback:
int
MyReverseCallback (char *host, int id, int version)
@{
  printf ("Hostname is: %s\n", host);
  return 0;
@}
@end group
@end example

@node Porting issues,  , Co-Server, Top
@chapter Porting issues

Serveez was always designed with an eye on maximum portability. Autoconf 
and Automake have done a great job at this. A lot of @code{#define}s help
to work around some of the different unices oddities. Have a look at
@file{config.h} for a complete list of all these conditionals.

The most doubtful might be the Win32 port. There are two different targets.
Where the @code{__MINGW32__} port refers to a native Win32 port. The home
of the team is @uref{http://www.mingw.org/}. The port to the
@code{__CYGWIN__} target always depends on the unix emulation layer DLL
@file{cygwin1.dll}. Both ports are more or less advanced at this time, but
for performance reasons it is always better to chose native Win32.

The are major differences between the Win32 and Unix implementations due
to the completely different API those systems provide.

@table @asis
@item Processes and Threads
Because process communication is usually done by a pair of unidirectional
pipes we chose that method in order to implement the Co-Servers in unices.
The Win32 implementation are threads which are still part of the main
process.

@item Sockets and Handles
In Win32 systems there is a difference in network sockets and file 
descriptors. Those we had to implement quite a complex main socket loop.

@item Named Pipes
Both systems Unix and Win32 do provide this functionality (Windows NT 4.0
and above). The main differences here are the completely different APIs.
On a usual unix you create a named pipe within the filesystem via 
@code{mkfifo()} and in Win32 you have to @code{CreateNamedPipe()} which
will create some special network device. A further difference is what you
can do with these pipes. On Win32 systems this @samp{network device} is
valid on remote machines. That is on Unices possible if the created 
filesystem node is located on a NFS. Named pipes on Unices are 
unidirectional, on Win32 these are bidirectional and instanciatable.
@end table

If if you want to compile Serveez with the native M$ Visual C++ compiler
you have to go quite a long way. But it is possible anyway. We assume you
got a Cygwin development environment somewhere, the Developer Studio
installation and @samp{serveez} and @samp{sizzle} in separate directories.

@table @asis
@item Step 1. Create development environment for VC.
In order to create both of the @file{config.h} files we need to execute
the @file{configure} script.
@example
@group
$ c:\Programme\DevStudio\VC\bin\VCVARS32.BAT
$ set PATH=%PATH%;c:\Programme\cygnus\cygwin-b20\H-i586-cygwin32\bin
$ set CC=cl -D__MINGW32__ -D_WIN32
$ set LD=link
@end group
@end example
@item Step 2. Configure.
@example
@group
$ sh configure --with-sizzle=../sizzle/
@end group
@end example
@item Step 3. Create project and workspace for both Serveez and Sizzle.
Start your Developer Studio and create a new project. For Serveez you need
to create a @samp{Win32 console application} and for Sizzle a
@samp{Win32 static library} then. For both projects you need to add all
the @file{.c} files form @file{src/} (Serveez) and @file{libsizzle/}
(Sizzle).

@item Step 4. Define options.
For configuring your projects you press @key{Alt-F7}. Make the following
definitions:

@table @asis
@item Preprocessor.
@code{_WIN32,__MINGW32__,__STDC__=0,HAVE_CONFIG_H,__MAKEDLL__=1} for 
Sizzle and
@code{_WIN32,__MINGW32__,__STDC__=0,HAVE_CONFIG_H,__USDLL__=1} for Serveez.

@item Include directories.
Add the following paths: @file{.,..,../sizzle,./src,../..}.

@item Object-Modules.
Simply add @file{wsock32.lib} and @file{sizzle.lib} (for Serveez only).

@item Library paths.
In order to link against the previously created Sizzle library you have
to specify the additional library path @file{../sizzle/libsizzle} in the
Serveez project.
@end table
@end table

Compiling now via @key{F7} you got a completely native Win32 application
which is linked agains the @file{KERNEL32.DLL} and @file{WINSOCK32.DLL}.

Now follows the list on which operating systems and architectures
Serveez has been build and tested successfully.

@itemize @bullet

@item FreeBSD 3.3 on Intel
@item FreeBSD 4.0 on Intel
@item FreeBSD 4.0 on Alpha
@item Linux 2.x.x on Intel
@item Linux 2.x.x on Alpha
@item Solaris 2.6, 2.7 on Sparc 32, Sparc 64
@item SunOS 5.6 on Intel
@item AIX 4.3 on RS6000
@item Windows 95 on Intel
@item Windows 98 on Intel
@item Windows Millenium Edition on Intel
@item Windows NT 4.0 on Intel
@item IRIX 6.x on MIPS
@item Tru64/OSF1 UNIX V4.0 (former Digital UNIX) on Alpha
@item Tru64/OSF1 UNIX V5.0 (former Digital UNIX) on Alpha

@end itemize

@contents
@bye
