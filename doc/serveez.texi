\input texinfo
@c %**start of header
@setfilename serveez.info
@settitle Serveez Documentation
@c %** end of header

@exampleindent 2
@include version.texi

@set PACKAGE Serveez
@set s_PACKAGE serveez
@set SIZZLE Sizzle
@set s_SIZZLE sizzle
@set b_SIZZLE SIZZLE

@dircategory Serveez - A server framework.
@direntry
* serveez: (serveez).           Serveez Documentation.
@end direntry

@titlepage
@title Serveez, version @value{VERSION}
@subtitle A server framework
@subtitle Edition @value{EDITION},  @value{UPDATED}
@author Stefan Jahn
@author Raimund Jacob

@page
@vskip 0pt plus 1filll

Copyright @copyright{} 2000 Stefan Jahn <stefan@@lkcc.org>@*
Copyright @copyright{} 2000 Raimund Jacob <raimi@@lkcc.org>@*
Copyright @copyright{} 1999 Martin Grabmueller <mgrabmue@@cs.tu-berlin.de>@*

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1
or any later version published by the Free Software Foundation.
A copy of the license is included in the section entitled "GNU
Free Documentation License".

@end titlepage

@node Top, Introduction, (dir), (dir)

@menu
* Introduction::          Introduction to Serveez
* Using Serveez:: Startup and command line options
* Concept::               Conceptional thoughts
* Server::                Server implementation
* Co-Server::             Co-Server implementation
* Porting issues::        Support of different platforms and operating systems
* Bibliography::          Useful documents we refer to
* License::               GNU General Public License
@end menu

@node Introduction, Using Serveez, Top, Top
@chapter Introduction

Serveez is a server framework. It provides routines and help for
implementing IP based servers (currently TCP, UDP and ICMP). It is also
possible to use named pipes for all connection oriented protocols.
We think it is worth the effort because many people need server functionality 
within their applications. However, many people experience problems 
with select()- or poll()-loops and non-blocking operations.
This application demonstrates various aspects of advanced network
programming in a portable manner. It is known to compile and run on 
GNU/Linux systems, as well as other 32-bit and 64-bit flavours of Unix, 
and on Microsoft Windows (9x/ME/NT/2000).
You can use it for implementing your own servers or for understanding how
certain network services and operations work.
The package includes a number of servers that work already: a HTTP server,
an IRC server, a Gnutella spider and some others. One of the highlights is
that you can run all protocols on the same port. The application itself is
single threaded but it uses helper processes for concurrent name resolution
and ident lookups.

@node Using Serveez, Concept, Introduction, Top
@chapter Using Serveez

@section Starting Serveez

To start Serveez simply type @samp{@value{s_PACKAGE}} at your 
command line prompt and press @key{RET}. This will invoke the 
@file{@value{s_PACKAGE}[.exe]} which will read its configuration 
from a file called @file{@value{s_PACKAGE}.cfg} in the current 
directory and run the server loop afterwards. Press @key{^C} to abort 
the execution of this program.

@section Command line options

@table @code
@item -h, --help
Display this help and exit.
@item -V, --version
Display version information and exit.
@item -i, --iflist
List local network interfaces and exit.
@item -f, --cfg-file=FILENAME
File to use as configuration file (@value{s_PACKAGE}.cfg).
@item -v, --verbose=LEVEL
Set level of logging verbosity.
@item -l, --log-file=FILENAME
Use FILENAME for logging (default is stderr).
@item -P, --password=STRING
Set the password for control connections.
@item -m, --max-sockets=COUNT
Set the maximum number of socket descriptors.
@item  -d, --daemon
Start as daemon in background.
@end table

@section Configuring Serveez

As noted above Serveez is configured via a configuration 
file which is by default @file{@value{s_PACKAGE}.cfg} and can be set 
by passing the -f command line argument. We are using the Scheme 
dialect called @value{SIZZLE} for this configuration file. @value{SIZZLE} is
maintained by Martin Grabmueller (@email{mgrabmue@@cs.tu-berlin.de}).
We provide an example configuration file in the @file{data/} directory. You
should be able to configure Serveez without learning scheme.

The configuration file is used to set special variables and to instantiate
servers. The following example shows how to set up a "foo" server.
You tell Serveez to instantiate a "foo" server by starting the
variable name with @samp{foo}.

@example
(define foo-server1 '#@{
        "reply" => "Hello. I am your foo server"
        @})
@end example

This defines some key-value mapping that configures the behaviour of the
new foo server.

When we are referring to a @samp{port configuration} this is a special hash
setting up a (network or file system) connection possibility to
Serveez. The structure of a port configuration is:

@example
"NameOfPortCfg" => #@{
        ;; one of those possibilities
        "proto"    => "tcp" || "udp" || "pipe" || "icmp"
        ;; tcp or udp port number
        "port"     => 42420
        ;; ip address to bind the server to
        "local-ip" => "*" || xxx.xxx.xxx.xxx
        ;; receiving pipe
        "inpipe"   => "MyRecvPipe"
        ;; sending pipe
        "outpipe"  => "MySendPipe"
        @}
@end example

We now have a closer look at the internals of Serveez. If you
are not interested in that have a look at the existing
servers (@xref{Existing Servers}.).

@node Concept, Server, Using Serveez, Top
@chapter Concept

@section I/O Strategy
Serveez's I/O strategy is the traditional @code{select()} method. It 
is serving many clients in a single server thread. This is done by setting
all network handles to non-blocking mode. We then use @code{select()} to tell 
which network handle have data waiting. This is the traditional Unix style
multiplexing.

An important bottleneck in this method is that @code{read()} or 
@code{sendfile()} from disk blocks if the page is not in core at the 
moment. Setting non-blocking mode on a disk file handle has no effect. 
Same thing goes for memory-mapped disk files. The first time a server
needs disk I/O, its process blocks, all clients must wait, and raw
non-threaded performance goes to waste. 

Unfortunately, @code{select()} is limited to the number of 
@code{FD_SETSIZE} handles. This limit is compiled in to the standard 
library and user programs (and sometimes the kernel). Nevertheless 
Serveez is able to serve about one thousand and more 
clients on GNU/Linux, a hundred on Win95 and some more on later Windows 
systems.

We chose this method anyway because it seems to be the most portable. 

An alternative method to multiplex client network connections is 
@code{poll()}. It is automatically used when @samp{configure} finds
@code{poll()} to be available. This will work around the builtin (g)libc's 
@code{select()} file descriptor limit.

@section Limits on open filehandles
@table @code

@item Any Unix
The limits set by @code{ulimit ()} or @code{setrlimit ()}.

@item Solaris
See the Solaris FAQ, question 3.45.

@item FreeBSD 
Use sysctl -w kern.maxfiles=nnnn to raise limit.

@item GNU/Linux
See Bodo Bauer's /proc documentation. On current 2.2.x kernels, 
@example
echo 32768 > /proc/sys/fs/file-max
echo 65536 > /proc/sys/fs/inode-max
@end example
increases the system limit on open files, and 
@example
ulimit -n 32768
@end example
increases the current process' limit. We verified that a process on 
Linux kernel 2.2.5 (plus patches) can open at least 31000 file 
descriptors this way. Another fellow has verified that a process on 
2.2.12 can open at least 90000 file descriptors this way (with 
appropriate limits). The upper bound seems to be available memory. 

@item Windows 9x/ME
On Win9x machines, there is quite a low limit imposed by the kernel: 
100 connections system wide (!). You can increase this limit by editing 
the registry key 
HKLM\System\CurrentControlSet\Services\VxD\MSTCP\MaxConnections. 
On Windows 95, the key is a DWORD; on Windows 98, it's a string. 
We have seen some reports of instability when this value is increased 
to more than a few times its default value.

@item Windows NT/2000
More than 2000 connections tested. Seems like the limit is due to
available physical memory.
@end table

@node Server, Co-Server, Concept, Top
@chapter Server

@menu
* Introduction to Servers::     Protocol servers in Serveez
* Writing Servers::             How to write internet protocol servers
* Existing Servers::            Which kind of servers do we have already ?
@end menu

@node Introduction to Servers, Writing Servers, Server, Server
@section Introduction to Servers

This package is a kind of server server. It allows different protocol
servers to listen on various TCP/UDP ports, on ICMP sockets and on named
pipes. Servers are instantiated with a certain configuration. It is
possible to run multiple different servers on the same port.

This chapter covers all questions about how to write your own internet
protocol server with this package. Most of the common tasks of
such a server have got a generic solution (default routines) which could be 
"overridden" by your own routines. There are some examples within this 
package. They are showing the possibilities with this package and how to
implement servers.

The @samp{foo} server does not do anything at all and is of no actual use
but could be a basis for a new protocol server. We are now going to describe
how this specific server works. Eventually the reader might get an 
impression of what is going on.

@node Writing Servers, Existing Servers, Introduction to Servers, Server
@section Writing Servers

@subsection Making and configuring preparations

Serveez is configured and built via automake and autoconf. That
is why you are not supposed to write your own Makefiles but simplified
@file{Makefile.am}s. Automake will automatically generate dependencies and
compiler/linker command lines. Here are the steps you basically need 
to follow:

@itemize @bullet
@item
Change to the @file{src/} directory in the source tree.

@item
Edit the @file{Makefile.am}. Add your sub directory name and library name
which you are going to create.

@item
Now create the sub directory and change into it.

@item
You need to create a new @file{Makefile.am} therein. If you want to have
this file @file{configure}d you need to add a further line to the 
@code{AC_OUTPUT()} statement in @file{configure.in} which is in the top
level directory. You have to put at least the following into the newly 
created @file{Makefile.am}:

@example
noinst_LIBRARIES = libfoo.a
AM_CPPFLAGS = -I..
CLEANFILES = *~
libfoo_a_SOURCES = foo-proto.h foo-proto.c
@end example

@item
Just have a look at all the other server directories. For more information
about automake read the info pages.

@end itemize

@subsection Server header file @file{foo-proto.h}

This file contains at least your server's configuration structure and
some global definitions of server routines which must be available from
the outside. Furthermore it contains the extern declaration of your 
server definition. The @code{foo} server implements all kinds of 
configuration items which can be integers, integer arrays, strings, string
arrays, port configurations and hash maps. Every item of the server 
configuration can later be manipulated from the configuration file.

@subsection Server implementation file @file{foo-proto.c}

If you want to define default values for your configuration you have
to define them it somewhere and put them into the default configuration 
structure. This structure will be used to instantiate your server. For
this example we called it simply @code{mycfg}.

In order to associate the configuration items in a server configuration 
to keywords within the configuration file you have to define an
array of key-value-pairs. This is done in the @code{foo_config_prototype} 
field. There are several macros which make different associations. These 
are the @code{REGISTER_*} macros which take three arguments. The first 
argument is the keyword which will occur in the configuration file, the 
second is the associated item in your default configuration structure 
and the last argument specifies if this item is defaultable or not.

@subsection Server definition

The server definition is in a way the @samp{class} of your server. Together
with the default values (@code{foo_config_prototype}) it serves as a
template for newly instantiated servers. The structure contains a long and a
short description of your server. The short name is used as the prefix of
all hash maps which define servers of this type. The long description is
used in the control protocol (@xref{Control Protocol Server}.). The server
defintion also contains the callbacks your server (mandatorily) provides.

@subsection Server callbacks

There are several callback routines, which get called in order to 
instantiate the server and for describing the actual behaviour of your 
server. Here are the description of all of these callbacks. Some of them
have to be implemented. Others have reasonable default values.

@table @code
@item global initializer (optional)
This callback is executed once for every type of server. Here you can
initialize data or whatever is shared between all instances of your server. 
For instance the http server would load the mime type file here. The 
@code{foo} server creates its default hash property because a hash cannot be
statically initialized.

@item global finalizer (optional)
If you want to free shared resources which were possibly allocated within
the global initializer you can do so here. The foo server frees its
default hash previously allocated in the global initializer.

@item instance initializer (mandatory)
Within this routine you can initialize everything you might need for one 
instance of your server. Secondly you have to bind this instance to some port
configuration. In most cases you want to have this port configuration
accessible via the configuration file. Therefore you have to 
@code{REGISTER_PORTCFG()} in your servers configuration definition. The port
configuration is then part of your servers instance configuration
structure. The foo server prints its whole configuration just for debugging
purposes. It simply shows how configurable items from the configuration
file correspond to the server instance configuration.

@item instance finalizer (optional)
The server instance finalizer gets its instance representation as argument.
You have to free all resources used by this server instance. The foo server
destroys its hash if it was not the default hash which gets freed within
the global finalizer.

@item protocol detection (mandatory)
Because it is possible to have more than one server listening on one 
network port we need to detect the type of client which is connecting
to this port. The foo servers checks if the first five bytes the client
was sending is identifying it as a foo client. This routine is getting
two arguments where the first one is a pointer to this servers instance
configuration and the second is the client socket object containing all
information of the client connection. This structure is described a bit
later. Be patient. For successful client detection return non-zero value. 

@item connect socket (mandatory)
If the client detection signaled success this routine is called to assign
the client connection to this servers instance. The arguments are just
the same as in the detection routine. In this callback you can assign
all the connection specific callbacks for your server and do some initial
things. The foo server sets the @code{check_request} callback to the 
@code{default_check_request} which is using the packet delimiter 
information to find whole packets. When a client sent such a packet the 
@code{handle_request} callback is executed. That is why the @code{foo} 
server assigns the @code{handle_request} method.

@item client info (optional)
If this callback is given the control protocol 
(@xref{Control Protocol Server}.) can give information about a specific
client if requested with @samp{stat id NUM}. The first argument given
is the server configuration hash and the second one the client's socket
structure. You have to return a static single line character string.

@item server info (optional)
This function is called when listing the server instances via 
@samp{stat all} from the control protocol (@xref{Control Protocol Server}.). 
The returned character string might be multiline separated by 
@code{\r\n} (no trailing separator). Usually you will return all the 
server configuration information.

@item timer (optional)
If this callback is not @code{NULL} it is called whenever there is some time 
left. It gets the server instance itself as argument. Actually it gets
called every second.

@item handle request (mandatory for UDP and ICMP servers)
The arguments to this callback are the client's socket structure, the 
address of the packet data and its length. When implementing an UDP or
ICMP server you need to return non-zero if your server could process the 
packet. Thus it is possible that there are multiple UDP servers on a 
single port.
@end table

@subsection Make your server available

You distribute your server by editing the @file{server.c} file in the
@file{src/} directory. There you have to include the the servers header 
file and add the server definition to the @code{all_server_definition} array.

@subsection More detailed description of the callback system and structures

The client connection information is stored within the @code{socket_t} 
object. All of the client connection specific callbacks get this object as
first argument. Following is a description of the elements of this object.

@table @code
@item id
The socket id is a unique id for a client connection.

@item version
This item validates this socket structure. If you pass the @code{id} and
@code{version} to a Co-Server you can check if the delivered socket 
structure is the original or not within the Co-Server callback.

@item flags
The flag field of the client connection contains informations about the
state of this connection. See @file{socket.h} in the @file{src/} directory 
for more information. Basically this bitfield specifies how this object
is handled by the main server loop.

@item userflags
This bitfield could be used for protocol specific information. You can use
is for any information.

@item boundary, boundary_size
If you are going to write a packet oriented protocol server you can use
the @code{default_check_request} method to parse packets. These two 
properties describe the packet delimiter.

@item send_buffer, send_buffer_size, send_buffer_fill
This is the outgoing data for a client connection object.

@item recv_buffer, recv_buffer_size, recv_buffer_fill
Within the receive buffer all incoming data for a connection object is 
stored. This buffer is at least used for the client detection callback.

@item read_socket()
This callback gets called whenever data is available on the socket.
Normally, this is set to a default function which reads all available
data from the socket and feeds it to @code{check_request}, but specific
sockets may need other policies.

@item write_socket()
This routine is called when data is is valid in the output buffer
and the socket gets available for writing. You normally leave this
callback untouched. It simply writes as much data as possible to the 
socket and removes the data from the send buffer. 

@item disconnected_socket()
This gets called whenever the socket is lost for some external reason.

@item connected_socket()
If some piece of code tries to connect to another host via 
@code{sock_connect} this connection might be established some time later.
This callback gets called when the socket is finally connected.

@item kicked_socket()
We call this whenever the socket gets closed by us.

@item check_request()
This gets called whenever data was read from the socket.
Its purpose is to check whether a complete request was read, and
if it was, it should be handled and removed from the input buffer.

@item handle_request()
This gets called when the @code{check_request} got a valid packet. The 
request arguments contains the actual packet and the second argument is the
length of this packet including the packet delimiter.

@item idle_func()
This callback gets called from the periodic task scheduler. Whenever
@code{idle_counter} (see below) is non-zero, it is decremented and
@code{idle_func} gets called when it drops to zero. @code{idle_func} can 
reset @code{idle_counter} to some value and thus can re-schedule itself 
for a later task.

@item idle_counter
Counter for calls to @code{idle_func}.

@item data
Miscellaneous field. Listener keeps array of server instances here.
This array is @code{NULL} terminated. Some servers store server specific 
information here.

@item cfg
When the final protocol detection in @code{default_detect_proto}
has been done @code{cfg} should contain a pointer to the actual 
configuration hash map taken from the server instance object.
@end table

@subsection Using Co-Servers

Co-Servers are designed to complete blocking tasks. Each Co-Server runs in
its own thread/process. There are several Co-Servers implemented: the dns, 
reverse dns and ident Co-Server. If you want to use them you have to 
@code{#include "coserver/coserver.h"}. Secondly you need to implement the 
callback which gets called when a Co-Server completed its task. This 
routine must be a @code{coserver_handle_result_t}. The first argument is 
the actual Co-Server result which might be @code{NULL} if the request 
could not  be fulfilled and the latter two arguments are the arguments 
you specified  yourself when issuing the request. To invoke a Co-Server 
you use one of the @code{coserver_*} macros. The @code{foo} server uses 
the reverse dns Co-Server to identify the host name of the remote client.

@node Existing Servers,  , Writing Servers, Server
@section Existing Servers

@menu
* Chat Server::                 Chat Server (aWCS, textSure) description
* HTTP Server::                 Integrated Web Server description
* IRC Server::                  EFNet IRC Server
* Control Protocol Server::     Serveez control center
* Foo Server::                  Example server implementation
* SNTP Server::                 Simple network time protocol server
* Gnutella Spider::             Gnutella Client description
* Tunnel Server::               Description of the port forwarder
@end menu

@node Chat Server, HTTP Server, Existing Servers, Existing Servers
@subsection Chat Server

@subsubsection General description

The whole Serveez package was originally written by Martin 
Grabmueller as a fast C backend for a chat system (now called textSure).
This can be found at @uref{http://www.textsure.net/}. The server 
implements two kinds of protocols. One is for the master server which 
does all the administrative stuff. The second is for the chat 
clients (applets or bots). Basically the chat server is a simple multicast
unit.

@subsubsection Specification of the Slave/Master server protocol of aWCS

@table @asis
@item Master server
The first client that connects and sends an aWCS initialize message
(see below) becomes the master server.
When the master server disconnects, all clients get kicked.

@item Other clients
All other clients have to send the aWCS client initialize message,
which is the string "aWCS\0" (note the final NUL character, which is
part of the message). Messages received from those clients are simply
sent to the master server with the client number of the sender
prefixed (see `Messages from clients').

@item Message format
A request consists of a sequence of characters terminated with the
NUL character '\0'.

@item Messages from clients
All messages from clients are routed to the master server, but
modified in such a way that 4 digits and one space precede the
original message. These 4 digits are the (decimal) client's id
right-padded with zeroes.

@item Messages from the master server
Messages that come from the master server must have the following
format:

The first character is one of the following and has a special meaning:

@multitable @columnfractions .15 .85
@item character
@tab meaning
@item 0
@tab Send message to all clients.
@item 1
@tab Send message to the clients denoted in the message.
@item 2
@tab Report status to the master server.
@item 3
@tab Kick the clients denoted in the message.
@item 4
@tab Turn off flood protection for the clients in the message.
@item 5
@tab Turn on flood protection for the clients in the message.
@item 6
@tab Initialization message.
@end multitable

Those special characters are followed by a single space.

Messages which require additional parameters (multicast for example)
carry these parameters after the space in a comma separated list of
client ids in the format mentioned above.  The client id list is terminated
by the \0 character terminating the request (if no parameters follow)
or by a single space (if parameters follow).  Note that no spaces are allowed
n comma separated lists.

@example
Example:

0 Hallo Welt\0
  - Send "Hallo Welt\0" to all clients except the 
    master server.

1 0001,0004,0006 Gruezi!\0
  - Send "Gruezi\0" to the clients 1, 4 and 6.

2 \0
  - Send status data back to the master server.

3 0003,0004\0
  - Kicks clients 3 and 4.

4 0004,0016\0
  - Turn off flood protection for clients 4 and 16.

5 0001,005\0
  - Turn on flood protection for clients 1 and 5.

6 \0
  - Initialize data structures and accept the 
    connection as the master server.
@end example

@item Status messages for the master server
The low level server posts messages to the master server on several
occasions, for example when clients connect, disconnect etc.

Status messages have the same format as other client messages for the
master server.  The client number in the message is 0000, followed by a
space, the status message type and additional parameters.

(FIXME: I dont think it's 0000 anymore. I think the server id is dynamically
allocated now)

@multitable @columnfractions .08 .4 .52
@item Type
@tab Description
@tab Parameter
@item 0
@tab Client has connected.
@tab Client id, client IP number:port
@item 1
@tab Client has disconnected.
@tab Client id, error code
@item 2
@tab Client got kicked.
@tab Client id, kick reason
@item 3
@tab Low level server is alive.
@tab 42
@item 4
@tab Notify time elapsed.
@tab 42
@end multitable

@multitable @columnfractions .2 .8
@item Error code
@tab Description
@item 0
@tab Success
@item 1
@tab Client closed connection
@end multitable

@multitable @columnfractions .2 .8
@item Kick reason
@tab Description
@item 0
@tab Flooding
@item 1
@tab Output buffer overflow
@end multitable

@end table

@subsubsection Configuration

@table @code
@item netport
The @code{netport} parameter is the default network port configuration
where you can specify the network port and IP address.

@item fsport
This parameter can be used to specify two named pipes as connection
possibility. It is meant for local installations of master server and
serveez.
@end table

@node HTTP Server, IRC Server, Chat Server, Existing Servers
@subsection HTTP Server

@subsubsection General description

The integrated HTTP server was originally thought to be a simple but fast
document server. But now it can even execute CGI scripts. The GET, HEAD and
POST methods are fully functional. Additionally Serveez produces 
directory listings when no standard document file 
(e.g. @file{index.html}) has been found at the requested document node
(directory).  Furthermore it implements a file cache for speeding up
repetitive HTTP request.

In comparison to other web server projects like Apache and Roxen this
web server is really fast. Comparative benchmarks will follow.
The benchmark system is a 233 MHz Mobile Pentium MMX. Both the server and
the client (http_load - multiprocessing http test client) ran on the same
computer.

@table @code
@item Small files
The small-file test load consists of 1000 files, each 1KB long, requested 
randomly.

@example
concurrent fetches   1   10   50  100  200  500  1000
hits/second        501  520  481  475  420  390   295
@end example

@item CGI
The CGI test load consists of a trivial "hello world" C program. I noticed
Linux (FIXME: kernel version?) to throw "Resource temporarily unavailable"
errors when fork()ing very fast. This limits the test to about 200 concurrent
fetches on the test system.

@item Large files
The large-file test load consists of 100 files, each 1MB long, requested 
randomly. Also, each connection is throttled to simulate a 33.6Kbps modem. 
Note that 1000 33.6Kbps connections is 3/4 of a T3. There was no problem to
get 1000+ concurrent fetches.
@end table

@subsubsection Configuration

The following options can be set from the configuration file.

@table @code
@item netport
This is the TCP port configuration hash wherein you can set the 
IP address this server should be bind to and the port the server is 
listening on.

@item indexfile
The @code{indexfile} parameter is the default file served by the HTTP 
server when the user does not specify a file but a document node
(e.g. @uref{http://www.textsure.net/}).

@item docs
The @code{docs} parameter is the document root where the server finds its
web documents.

@item userdir
Each @samp{~user} request gets converted into the given users home
directory. The string will be appended to this directory. Its default
value is @samp{public_html}.

@item cgi-url
This parameter is the first part of the URL the HTTP server identifies a
CGI request. For instance if you specify here @file{/cgi-bin} and the
user requests @uref{http://www.textsure.net/cgi-bin/test.pl} then the
HTTP server tries to execute the program @file{test.pl} within the
@code{cgi-dir} (see below) and pipes its output to the user.

@item cgi-dir
The @code{cgi-dir} is the CGI document (on the server).

@item cgi-application
Within the MinGW32 and native port you can use this hash to associate
certain file suffices with applications on your computer (e.g. "pl" with
"perl"). This is necessary because there is no possibility to check whether
a file is executable on Win32.

@item cache-size
This specifies the size of the document cache.

@item cache-entries
This parameter specifies the maximum number of HTTP file cache entries
(files). When you instantiate more than one HTTP server the biggest value
wins. The HTTP file cache is shared by all HTTP servers.

@item timeout
The @code{timeout} value is the amount of time in seconds after which 
a keep-alive connection (this is a HTTP/1.1 feature) will be closed when
it has been idle.

@item keepalive
On one keep-alive connection can be served the number of @code{keepalive}
documents at all. Then the connection will be closed.
(FIXME: write more prosa: why is that neccessary? The apache bug? To be
 on the safe side?)

@item default-type
The @code{default-type} is the default content type the HTTP server
assumes if it can not identify a served file by the @code{types} hash
and the @code{type-file} (see below).

@item type-file
This should be a file like the @file{/etc/mime.types} on Unix systems.
It associates file suffices with MIME types.

@item types
If you want to specify special content types do it here. This parameter
is a has associating file suffices with HTTP content types (MIME types).

@item admin
Your address, where problems with the server should be e-mailed.
This address appears on some server-generated pages, such as error
documents.

@item host
This is the native host name of your webserver. Sometimes the server has
to send back its own name to the client. It will use this value.
Be aware that you cannot invent such a name.

@item nslookup
If this number is non-zero the HTTP server invokes a reverse DNS lookup
for each client connection in order to replace the remote ip address with
the remote host name in the access logfile.

@item logfile
The location of the access logfile. For each HTTP request a line gets
appended to this file.
(FIXME: default value?)

@item logformat
The format of the access logfile. There are special placeholders for
different kinds of logging information.

@table @code
@item %h
the remote host name the request came from
@item %t
when was the entity accessed
@item %u
what kind of entity was requested
@item %r
which document referred to this document
@item %a
what kind of web browser did the remote client use
@item %c
the http response return code for this request
@item %l
delivered content length in bytes
@end table
@end table
(FIXME: default value? Some notes on the CLF common logfile format ?)

@node IRC Server, Control Protocol Server, HTTP Server, Existing Servers
@subsection IRC Server

@subsubsection General description

Internet Relay Chat. The mother of all chat systems.
The integrated IRC server is intended to be compatible with the EFNet.
There are no good possibilities to test this in real live, so it is
still under heavy construction. But it can be used as a standalone server
anyway.

IRC itself is a teleconferencing system, which (through the use of
the client-server model) is well-suited for running on many machines
in a distributed fashion. A typical setup involves a single process
(the server) forming a central point for clients (or other servers)
to connect to, performing the required message delivery/multiplexing
and other functions.

The server forms the backbone of IRC, providing a point for clients and
servers to connect to. Clients connect to talk to each other. Servers
connect to build up a network of servers. IRC servers connections have
to build up a spanning tree. Loops are not allowed. Each server acts
as a central node for the rest of the network it sees.

@subsubsection Configuration

The following table shows the configuration keys provided. Most of the
configuration items are similar to those of an Hybrid IRC server. They
seem archaic at first sight but IRC operators are used to it. Refer to
the Hybrid documentation for further information.
(FIXME: where to find the Hybrid documentation?)

@table @code
@item port
The @code{port} parameter is, as in all the server configurations, the
port configuration for this server, specifying IP address and the TCP/IP 
port the server should listen on.

@item MOTD-file
When a user initially joins it will get this file's content as the
message of the day comment. When changing on disk the server will notice
that and reload the file automatically.

@item INFO-file
The @code{INFO-file}s content gets displayed when the user issues the
/INFO command.

@item tsdelta
This value is the timestamp delta value to UTC in seconds.
(FIXME: uh? please tell me more)

@item admininfo, email, location1, location2
Some administrative information delivered on the /ADMIN command.

@item M-line (Mandatory)
This IRC server's configuration. The format of this line is:@*
":" VirtualHostName@*
":" OptionalBindAddress (real hostname)@*
":" TextName (FXIME: uh?)@*
":" Port@*
(FIXME: what's the difference between M-line and 'port' parameter)

@item A-line (Mandatory)
The administrative info, printed by the /ADMIN command.@*
":" administrative info (department, university)@*
":" the server's geographical location@*
":" email address for a person responsible for the irc server@*
(FIXME: what's the difference between A-line and the admininfo, email,
 location1, location2 fields)

@item Y-lines (Suggested)
The connection classes.@*
":" class number (higher numbers refer to a higher priority)@*
":" ping frequency (in seconds)@*
":" connect frequency in seconds for servers, 0 for client class@*
":" maximum number of links in this class @*
":" send queue size@*
(FIXME: write more)

@item I-lines (Mandatory)
Authorization of clients, wildcards permitted, a valid client is matched
@email{user@@ip} OR @email{user@@host}.@*
":" user@@ip, you can specify @samp{NOMATCH} here to force matching 
user@@host@*
":" password (optional)@*
":" user@@host@*
":" password (optional)@*
":" connection class number (YLine)@*

@item O-lines (Optional)
Authorize operator, wildcards allowed.@*
":" user@@host, user@@ forces checking ident@*
":" password@*
":" nick@*

@item o-lines (Optional)
Authorize local operator.
":" user@@host, user@@ forces checking ident@*
":" password@*
":" nick@*
(FIXME: i just copied the items from above. correct?)

@item C-lines (Networked)
List of servers to connect to.@*
Note: C and N lines can also use the user@@ combination in order to 
check specific users (ident) starting servers. C and N lines are 
usually given in pairs.@*
":" host name@*
":" password@*
":" server name (virtual)@*
":" port (if not given we will not connect)@*
":" connection class number (YLine)@*

@item N-lines (Networked)
Server which may connect.@*
":" host name@*
":" password@*
":" server name (virtual host name)@*
":" password@*
":" how many components of your own server's name to strip off the 
front and be replaced with a @samp{*}.@*
":" connection class number (YLine)@*

@item K-lines (Optional)
Kill user, wildcards allowed.@*
":" host@*
":" time of day@*
":" user@*
@end table

(FIXME: write something about wildcards in general. what about
 'user' vs. '!user' and so on.)

@node Control Protocol Server, Foo Server, IRC Server, Existing Servers
@subsection Control Protocol Server

@subsubsection General description

Serveez implements something like a telnet protocol for 
administrative purposes. You just need to start a telnet session like:
@example
$ telnet www.textsure.net 42420
@end example
After pressing @key{RET} you will be asked for a password which you
might setup passing Serveez the -P argument. 
@xref{Using Serveez}. The next section describes the interactive commands
available.

@subsubsection Using the Control Protocol

@table @samp
@item help
This command will give you a very short help screen of all available
commands.

@item quit
This command closes the connection to Serveez.

@item restart ident
Restarts the internal ident Co-Server. This is useful if you just want
to start a new one if the old one died or is otherwise unusable.

@item restart dns
Restarts the internal dns lookup server.

@item restart reverse dns
Restarts the internal reverse dns lookup server.

@item killall
This might be useful if Serveez seems to be unstable but you do not
want to restart it. With @samp{killall} you disconnect all client
network connections except the control protocol connections.

@item kill id NUM
Disconnects a specific connection identified by its ID. These IDs will
be stated when you type @samp{stat con} (see below).

@item stat
General statistics about Serveez. This will show you some useful
information about the computer Serveez is running on and about the
state of Serveez in general.

@item stat coserver
Statistics about all running Co-Server instances.

@item stat SERVER
This command is for selecting certain Server instances to be listed.
SERVER is one of server names you specified in the configuration file.

@item stat id NUM
Show statistics about a specific connection. This will give you all
available information about every connection you specified.
@xref{Writing Servers}, for more information about how to provide these
information.

@item stat con
Connection statistics. This will give a list of all socket structures
within Serveez. If you want more detailed information about specific
connections, Co-Servers or Servers you need to request these information
with @samp{stat id NUM} or @samp{stat all}.

@item stat all
Server and Co-Server instance statistics. This command lists all
the information about instantiated servers and Co-Servers.
@xref{Writing Servers}, for more information about how to provide these
information.

@item stat cache
HTTP cache statistics. This command produces an output something like the 
following where @samp{File} is the short name of the cache entry, 
@samp{Size} the cache size, @samp{Usage} the amount of connections 
currently using this entry, @samp{Hits} the amount of cache hits, 
@samp{Recent} the cache strategy flag (newer entries have larger numbers) 
and @samp{Ready} is the current state of the cache entry.

@example
File                      Size  Usage  Hits Recent Ready
zlib-1.1.3-20000531.zip  45393      0     0      1 Yes
texinfo.tex             200531      0     0      2 Yes
shayne.txt                2534      0     1      1 Yes

Total : 248458 byte in 3 cache entries
@end example

@item kill cache
Reinitialize the HTTP file cache. Flushes all files from the cache.
@end table

@subsubsection Configuration

@table @code
@item netport
Sets up the TCP port and local address. It can be useful to declare a
@code{local-ip} within this hash when you do not
want people using this protocol from outside.
@end table

@node Foo Server, SNTP Server, Control Protocol Server, Existing Servers
@subsection Foo Server

The Foo Server is a simple example on how to write internet protocol
servers with Serveez. @xref{Writing Servers}.
(FIXME: the foo server can be configured. write something!)

@node SNTP Server, Gnutella Spider, Foo Server, Existing Servers
@subsection SNTP Server

@subsubsection General
The SNTP server can be querried with the @samp{netdate} command. It is used
to synchronize time and dates between internet hosts. The protocol is
described in the ARPA Internet RFC 868. Thus it is not really an SNTP server
as described by RFC 2030 (Simple Network Time Protocol (SNTP) Version 4 for
IPv4, IPv6 and OSI). It is rather an excellent example on how to implement
an UDP server in Serveez. 

This protocol provides a site-independent, machine readable date and
time. The Time service sends back time in seconds since midnight on
January first 1900.

One motivation arises from the fact that not all systems have a
date/time clock, and all are subject to occasional human or machine
error. The use of time-servers makes it possible to quickly confirm or
correct a system's idea of the time, by making a brief poll of several
independent sites on the network.

@subsubsection Configuration
The configuration of this server knows just a single item which is the
port configuration.

@table @code
@item netport
This item specifies the protocol (which is "udp"), the network port (by
default 37) and the local ip address on which the server socket is bound
to (default is any ip address).
@end table

@node Gnutella Spider, Tunnel Server, SNTP Server, Existing Servers
@subsection Gnutella Spider

@subsubsection What is it ?
The Gnutella net is a peer-to-peer network which is based on
client programs only. There are no servers. The network itself is formed
by client connections only. Generally the Gnutella network is for sharing
files of any kind.

This Gnutella spider is for seeking the needle in the haystack. Once 
connected to the network it regularly tries to find certain files in there.
It keeps track of all connected clients and tries to reconnect them if
the current connections are lost.
(FIXME: write some more: who invented it, what other clients are there)

@subsubsection Configuration
The Gnutella spider knows the following configurations items.

@table @code
@item port
This entry has to contain @samp{tcp} for @samp{proto} and some port and
network interface. The default port is 6346. If you want to see the host
catcher list of this Gnutella spider you can connect to this port with 
any WWW browser at @uref{http://localhost:6346/@code{net-url}}.

@item net-url
The above url is configurable via this item.

@item hosts
This is the start of the haystack,
the initial host list of the clients the spider tries to 
connect to. Each list item should be of the format @code{ip:port} 
(e.g. @samp{146.145.85.34:6346}). If the port information is left
blank it defaults to 6346. If you need some entry point for 
the gnutella network have a look at @uref{http://www.gnutellahosts.com/} 
or @uref{http://www.gnutellanet.com/}.

@item search
This is the needle. Each search line is either a set of 
space delimited tokens where every token must match. Or a kind of wildcard
expression including @samp{?} and @samp{*}.
Search lines are always matched case insensitive.

@item search-limit
This limits how many results the Gnutella spider returns to other people 
searching your files.
(FIXME: default value? I rule of thumb for this value?)

@item max-ttl
Every Gnutella packet has got a TTL. This is the maximum TTL allowed for
outgoing packets.
(FIXME: default value? I rule of thumb for this value?)

@item ttl
When creating a new Gnutella packet we use this as TTL.
(FIXME: default value? I rule of thumb for this value?)

@item download-path
This is where the spider saves needles in.

@item share-path
Here are all the files we share with others. The Gnutella spider will 
recurse into directories. So be careful with this option.

@item max-downloads
Maximum number of concurrent downloads from the network.

@item max-uploads
Maximum number of concurrent uploads to the network.

@item connection-speed
This is what we send as our connection speed in KBit/s. We also use this
value to throttle down the network transfer rate for file uploads.

@item min-speed
Search for needles on hosts with a minimum speed. Set it to 0 if you do
not care about that. This value is in KBit/s, too.

@item file-extensions
If we get replies on search queries we check if the file extension of this
reply matches one of these extensions. Useful extensions are @samp{mp3} and
@samp{mpg}.

@item connections
This is the number of concurrent connections the Gnutella spider tries
to keep up to the network. The IP addresses and the port information is
taken from the host catcher hash.

@item force-ip
You can force the Gnutella spider to send outgoing replies with this
IP as host information. Must be in dotted decimals notation. This is 
useful if you are behind a masquerading gateway. You need to install
some kind of port forwarder on the gateway so other people can reach you
from the outside. Serveez is a good port forwarder.

@item force-port
Force the Gnutella spider to send outgoing replies with this PORT as 
port information. See above for more information.
@end table

@node Tunnel Server, , Gnutella Spider, Existing Servers
@subsection Tunnel Server

@subsubsection General description
The Tunnel server is for mapping one port configuration to another.
So we should rather speak of a port forwarder. Two portforwarders can form a
tunnel. Generally this means that you can setup Serveez to accept 
network connections in order to pass all network data on this 
line to another address. This can be useful to workaround gateways and 
firewalls. When instantiating an ICMP source or destination you must
ensure root privileges for the application. One of the given examples
in @file{serveez.cfg} shows how you can setup a tunnel server for 
forwarding a pipe connection. Please keep in mind when forwarding an 
ICMP or UDP connection to an TCP or pipe connection the data is not
reliable anymore because these are low level network protocols and we are 
not willingly to reimplement a TCP stack. 
(FIXME: what source-destination combinations are allowed? what protocol
 is used? what is safe to do and what is not?)

@subsubsection Configuration
This might be the most easiest configuration to setup. You essentially
need to define the source port configuration and the target port 
configuration. The @file{@value{s_PACKAGE}.cfg} in the @file{data/} 
directory shows two example configurations how to tunnel TCP 
connections over UDP and ICMP. The UDP tunnel accesses the standard 
HTTP port 80 and the ICMP tunnel accesses the standard Telnet port 23.

@table @code
@item source
The source port configuration.

@item target
The target port configuration.
@end table

@node Co-Server, Porting issues, Server, Top
@chapter Co-Server

@menu
* What are Co-Servers::         The use of Co-Servers in Serveez
* Writing Co-Servers::          How to write Co-Servers with Serveez
* Existing Co-Servers::         What kind of Co-Servers already exist ?
@end menu

@node What are Co-Servers, Writing Co-Servers, Co-Server, Co-Server
@section What are Co-Servers

If it is necessary to complete blocking tasks in Serveez you have 
to use Co-Servers. The actual implementation differs on platforms. On Unices
they are implemented as processes communicating with Serveez over pipes.
on Win32 Serveez uses threads and shared memory.

@node Writing Co-Servers, Existing Co-Servers, What are Co-Servers, Co-Server
@section Writing Co-Servers

@subsection Making and configuring preparations

First you have to change into the @file{src/coserver/} directory of the 
Serveez package. Then edit the @file{Makefile.am} and add your 
header and implementation file to the @code{libcoserver_a_SOURCES}
variable.

@subsection Co-Server header file

You have to declare the Co-Server handle routine here. This callback
gets the input buffer argument and delivers the output buffer result.
Both of these buffers are supposed to be lines separated by a @samp{\n}.

@subsection Co-Server implementation file

Here you need to @code{#include "coserver.h"} and implement the 
Co-Server handle routine declared in the Co-Server header file. This 
can be any blocking system call. On successful completion you 
can return the result or NULL on errors. The input and output 
buffers are plain strings and can have any format with one exception. 
Because the Co-Servers communicate via a line protocol with 
Serveez these buffers must not contain @samp{\n} (0x0d).

@subsection Make your Co-Server available in Serveez

For this you have to edit @file{coserver.h} and @file{coserver.c} in the
@file{src/coserver/} directory. In the header file you have to define a 
further COSERVER_* id (macro) and set the MAX_COSERVER_TYPES define to the 
appropriate value. Then you should define a further coserver_* macro in the 
same file.

In @file{coserver.c} you have to implement the coserver_* macro. This macro
takes three arguments. The first is always specific to your Co-Server and is
used to create the actual request string. Then follows the result callback
routine, and an optional argument for this callback. The latter two are
simply passed to the @code{coserver_send_request} routine. This routine 
takes four arguments where the first is the previously defined 
COSERVER_* id and the second is the input buffer for the coserver handle 
routine without the trailing @samp{\n}.

Then you need to add your Co-Server to the @code{int_coserver_type} array
specifying the COSERVER_* id, the Co-Server description, the Co-Server
handle routine discussed above, the number of Co-Server instances to be
created and an optional initialization routine.

@node Existing Co-Servers,  , Writing Co-Servers, Co-Server
@section Existing Co-Servers

@subsection Identification (Ident) Co-Server

The Identification protocol is briefly documented in RFC1413. It
provides a means to determine the identity of a user of a particular 
TCP connection. Given a TCP port number pair, it returns a character 
string which identifies the owner of that connection on the server's
(that is the client's) system.

This is a connection based application on TCP. A server listens for
TCP connections on TCP port 113 (decimal). Once a connection is
established, the server reads a line of data which specifies the
connection of interest. If it exists, the system dependent user
identifier of the connection of interest is sent as the reply. The
server may then either shut down the connection or it may continue to
read/respond to more queries.

The Ident Co-Server is a client to this kind of service. For
every established network connection you can use this service by calling
the appropriate macro from @file{coserver.h}. But you could also use the
Ident Co-Server as is without this macro.
The messages from Serveez to the this Co-Server are formated this way:

@example
Format:
RemoteAddressInDottedDecimals ":" RemotePort ":" LocalPort

Macro:
coserver_ident (sock, MyIdentCallback, sock->id, sock->version);
@end example

In this context @code{sock} is of type @code{socket_t} and 
@code{MyIdentCallback} is something like the following example. Both
of the last two (optional) arguments identify a valid socket structure
and @code{user} can be NULL if there is no ident daemon running on the 
foreign machine. The last two argument within the above macro will be the 
last two arguments in the callback below. Thus you will know what kind of 
data the invocation of the callback is related to.

@example
Callback:
int
MyIdentCallback (char *user, int id, int version)
@{
  printf ("Identified user: %s\n", user);
  return 0;
@}
@end example

@subsection Domain Name Server (DNS) Co-Server

The DNS Co-Server is using @code{gethostbyname()} to translate a given
hostname to the associated IP address. The format of the Co-Server input
line and the macro from @file{coserver.h} is shown below. The IRC server is
currently using this Co-Server for resolving its @samp{?-Lines}.
@xref{Existing Servers}, for more information. In the example below
@code{realhost} is something like @samp{www.textsure.net}.

@example
Format:
RemoteHostname

Macro:
coserver_dns (realhost, irc_connect_server, ircserver, NULL);

Callback:
int
irc_connect_server (char *ip, irc_server_t *server)
@{
  printf ("The ip address is: %s\n", ip);
  return 0;
@}
@end example

@subsection Reverse Domain Name Server (reverse DNS) Co-Server

As easily guessed from the name this Co-Server is just doing the reverse
as the DNS Co-Server. It translates a given IP address into a hostname
using @code{gethostbyaddr()}. In the macro the ip address is given
as an @code{unsigned long} in host byte order. The Reverse DNS 
Co-Server itself takes something like @samp{192.168.2.1}.

@example
Format:
RemoteAddressInDottedDecimals

Macro:
coserver_reverse (addr, MyReverseCallback, sock->id, sock->version);

Callback:
int
MyReverseCallback (char *host, int id, int version)
@{
  printf ("Hostname is: %s\n", host);
  return 0;
@}
@end example

@node Porting issues, Bibliography, Co-Server, Top
@chapter Porting issues

Serveez was always designed with an eye on maximum 
portability. Autoconf and Automake have done a great job at this. 
A lot of @code{#define}'s help to work around some of the different 
Unix' oddities. Have a look at @file{config.h} for a complete list 
of all these conditionals.

Most doubtful might be the Win32 port. There are two different targets.
Where the @code{__MINGW32__} port refers to a native Win32 port. The home
of the team is @uref{http://www.mingw.org/}. The port to the
@code{__CYGWIN__} target always depends on the Unix emulation layer DLL
@file{cygwin1.dll}. Both ports are more or less advanced at this time, but
for performance reasons it is always better to chose native Win32.
(FIXME: In the meantime we have 3 targets: cygwin, mingw and native, dont
 we?)

There are major differences between the Win32 and Unix implementations due
to the completely different API those systems provide.

@table @asis
@item Processes and Threads
Because process communication is usually done by a pair of unidirectional
pipes we chose that method in order to implement the Co-Servers in Unix.
The Win32 implementation are threads which are still part of the main
process.

@item Sockets and Handles
On Win32 systems there is a difference in network sockets and file 
descriptors. Thus we had to implement quite a complex main socket loop.

@item Named Pipes
Both systems Unix and Win32 do provide this functionality (Windows NT 4.0
and above). The main differences here are the completely different APIs.
On a common Unix you create a named pipe within the filesystem via 
@code{mkfifo()}. On Win32 you have to @code{CreateNamedPipe()} which
will create some special network device. A further difference is what you
can do with these pipes. On Win32 systems this @samp{network device} is
valid on remote machines.
You have to crate the fifo on a NFS shared filesystem to accomplish the same
on Unix. (FIXME: did we actuallt try that?)
Named pipes on Unix are unidirectional, on Win32 they are bidirectional
and instantiatable.

@item Winsock Versions
There are some difference between the original Winsock 1.1 API and the new
version 2.2.x. In a nutshell, WinSock 2 is WinSock 1.1 on steroids, it's 
a superset of 1.1's APIs and architecture. In addition to its new features, 
it also clarifies existing ambiguities in the 1.1 WinSock specification 
and adds new extensions that take advantage of operating system features 
and enhance application performance and efficiency. Finally, WinSock 2 
includes a number of new protocol-specific extensions. These extensions
--such as multicast socket options-- are relegated to a separate annex, 
since the main WinSock 2 protocol specification is protocol-independent. 

The Winsock DLL and import library for version 1.1 are @file{wsock32.dll}
and @file{wsock32.lib} and for version 2.2 it is @file{ws2_32.dll} and
@file{ws2_32.lib}. Serveez is currently using the 1.1 version
because there was no reason yet to switch to version 2.2.

The Winsock API is still a bit buggy. Connected datagram behaviors are 
not pertinent to any WinSock 2 features, but to generic WinSock. On Win95 
it's possible to use recvfrom()/WSARecvFrom() on a "connected" UDP socket, 
but on NT4 recvfrom()/WSARecvFrom fail with 10056 (WSAEISCONN). NOTE: 
sendto()/WSASendTo() fail with WSAEISCONN on both (which I don't see 
any reason for, but anyway...).

@item Raw sockets on Windows systems
Raw sockets require Winsock 2. To use them under Windows NT/2000, you must 
be logged in as an Administrator. On any other Microsoft's we are using 
the ICMP.DLL (an idiotic and almost useless API that some guys insist on 
using in their applications). This DLL is an undocumented API for sending 
ICMP echo packets, also called "pings". This API works fine and is present 
on all current Windows boxes with Microsoft Winsocks, but Microsoft says 
they'll replace it as soon as something better comes along. (Microsoft's 
been saying this since the Windows 95 days, however, yet this functionality 
still exists in Windows 2000.)

@item Miscellaneous
To use the vanilla Win32 winsock, you just need to #define Win32_Winsock 
and #include "windows.h" at the top of your source file(s). You will also
want to add -lwsock32 to the compiler's command line so you link against 
libwsock32.a. 

How do I make the console window go away ?
The default during compilation is to produce a console application. If you 
are writing a GUI program, you should either compile with -mwindows as
explained above, or add the string "-Wl,--subsystem,windows" to the GCC 
command line. 

What preprocessor macros do I need to know about ?
We use _WIN32 to signify access to the Win32 API and __CYGWIN__ for access 
to the Cygwin environment provided by the dll. 
We chose _WIN32 because this is what Microsoft defines in VC++ and we 
thought it would be a good idea for compatibility with VC++ code to
follow their example. We use _MFC_VER to indicate code that should be 
compiled with VC++. 

Why we do not use pipes for Co-Servers ?
Windows differentiates between sockets and file descriptors, that's why 
you can not select() file descriptors. Please close() the pipe's 
descriptors via CloseHandle() and not closesocket(), because this will fail.

The C run-time libraries have a preset limit for the number of files that
can be open at any one time. The limit for applications that link with the
single-thread static library (LIBC.LIB) is 64 file handles or 20 file
streams. Applications that link with either the static or dynamic
multithread library (LIBCMT.LIB or MSVCRT.LIB and MSVCRT.DLL), have a limit
of 256 file handles or 40 file streams. Attempting to open more than the
maximum number of file handles or file streams causes program failure.

I know MinGW uses the msvcrt.dll and hence should have the above limitation
but what about cygwin which uses glibc ? Just curious ... i dont think there
is any operating system limitation. May be some TLS issue from Microsoft or
some other stuff like that...

As far as I know, one of the big limitations of winsock is that
the SOCKET type is *not* equivalent to file descriptor. It is
however with BSD and POSIX sockets. That is one of the major reasons for
using a separate data type, SOCKET, not an int, i typical type for a
file desciptor. This implies that you cannot mix SOCKETs and stdio,
sorry. This is the case when you use -mno-cygwin.

Actually they are regular file handles, just like any other. There is a 
bug in all 9x/kernel32 libc/msv/crtdll interface implementations 
GetFileType() returns TYPE_UNKNOWN for handles to sockets
(FIXME: what does 'for handles to sockets' mean?). Since this 
is AFAIK the only unknown type there is, you know you have a socket handle.
There is a fix in the more recent perl distributions that you can use as a 
general solution. -loldnames -lperlcrt -lmsvcrt will get you TYPE_CHAR
for socket handles. That are put into an fd with _open_osfhandle()
also fixes several other nasty bugs in the MS libcXXX (FIXME: what does the
last sentence mean?)
@end table

If you want to compile Serveez with the native 
M$ Visual C++ compiler you have to go quite a long way. But it is 
possible anyway. We assume you got a Cygwin development environment 
somewhere, the Developer Studio installation and @samp{@value{s_PACKAGE}} 
and @samp{@value{s_SIZZLE}} in separate directories.

@table @code
@item Step 1. Create development environment for VC.
In order to create both of the @file{config.h} files we need to execute
the @file{configure} script.
@example
$ c:\Programme\DevStudio\VC\bin\VCVARS32.BAT
$ set PATH=%PATH%;c:\Programme\cygwin\bin
$ set CC=cl -D__MINGW32__ -D_WIN32
$ set LD=link
@end example

@item Step 2. Configure.
@example
$ sh configure --with-@value{s_SIZZLE}=../@value{s_SIZZLE}/ --disable-debug
@end example

@item Step 3. Create project and workspace for both Serveez and @value{SIZZLE}.
Start your Developer Studio and create a new project. For 
Serveez you need to create a @samp{Win32 Console Application} 
and for @value{SIZZLE} a @samp{Win32 Dynamic-Link Library} then. For both 
projects you need to add all the @file{.c} files form @file{src/} 
(Serveez) and @file{lib@value{s_SIZZLE}/} (@value{SIZZLE}).

@item Step 4. Define options.
For configuring your projects press @key{Alt-F7}. Make the following
definitions:

@table @code
@item Preprocessor.
@code{_WIN32}, @code{__MINGW32__}, @code{__STDC__=0}, @code{HAVE_CONFIG_H},@* 
@code{__@value{b_SIZZLE}_EXPORT__=1}@*
for @value{SIZZLE} and@*
@code{_WIN32}, @code{__MINGW32__}, @code{__STDC__=0}, @code{HAVE_CONFIG_H},@*
@code{__@value{b_SIZZLE}_IMPORT__=1}@*
for Serveez.

@item Include directories.
Add the following paths: @file{.,..,../@value{s_SIZZLE},./src,../..}.

@item Object-Modules.
Simply add @file{kernel32.lib}, @file{ws2_32.lib}, @file{advapi32.lib}, 
@file{shell32.lib}, @file{user32.lib} and @file{lib@value{s_SIZZLE}.lib} 
(for Serveez only).

@item Library paths.
In order to link against the previously created @value{SIZZLE} library 
you have to specify the additional library path 
@file{../@value{s_SIZZLE}/lib@value{s_SIZZLE}} in the Serveez 
project.
@end table
@end table

Compiling now via @key{F7} you got a completely native Win32 application
which is linked against the above dynamic link libraries.

Now follows the list on which operating systems and architectures
Serveez has been build and tested successfully.

@itemize @bullet

@item FreeBSD 3.3 on Intel
@item FreeBSD 4.0 on Intel
@item FreeBSD 4.0 on Alpha
@item GNU/Linux 2.x.x on Intel
@item GNU/Linux 2.x.x on Alpha
@item GNU/Linux 2.4.0-xxx on i64 (Itanium prototype)
@item Solaris 2.6, 2.7 on Sparc 32, Sparc 64
@item SunOS 5.6 on Intel
@item AIX 4.3 on RS6000
@item Windows 95 on Intel
@item Windows 98 on Intel
@item Windows Millenium Edition on Intel
@item Windows NT 4.0 on Intel
@item Windows 2000 on Intel
@item IRIX 6.x on MIPS
@item Tru64/OSF1 UNIX V4.0 (former Digital UNIX) on Alpha
@item Tru64/OSF1 UNIX V5.0 (former Digital UNIX) on Alpha

@end itemize

@node Bibliography, License, Porting issues, Top
@chapter Bibliography

This section contain some of the documents and resources we read and used
to implement various parts of this package. They appear in no specific
order.

@enumerate
@item 
RFC 760
The Internet Protocol
@item 
RFC 1071
Computing the Internet Checksum
@item 
RFC 1413
Identification Protocol
@item 
RFC 1459
Internet Relay Chat Protocol
@item 
RFC 1945
Hypertext Transfer Protocol -- HTTP/1.0
@item 
RFC 2068
Hypertext Transfer Protocol -- HTTP/1.1
@item 
RFC 2616
Hypertext Transfer Protocol -- HTTP/1.1
@item 
RFC 768
User Datagram Protocol
@item 
RFC 791
Internet Protocol
@item 
RFC 777
Internet Control Message Protocol
@item 
@uref{http://gnutelladev.wego.com/}
The Gnutella Protocol
@item 
@uref{http://www.efnet.org/}
The official EFNet site
@item 
@uref{http://www.sockets.com/}
Winsock Development Information
@item 
@uref{http://www.cyberport.com/~tangent/programming/winsock/}@*
Winsock Programmer's FAQ
@end enumerate

Some global FIXMEs:
@enumerate
@item 
(FIXME: add link to some Hybrid page)
@item
(FIXME: perhaps use 'serveez' instead of 'Serveez')
@item
(FIXME: perhaps use 'coserver' instead of 'Co-Server')
@item
(FIXME: always document types in configuration items)
@item
(FIXME: netport should alway be documented more verbose. The allowed
 proto types are missing in some places)
@item
(FIXME: move chat server down to be the last)
@end enumerate

@node License, , Bibliography, Top
@chapter License

@section GNU General Public License Version 2, June 1991
Serveez is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or any later version.

This software is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this package; see the file COPYING.  If not, write to
the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.

Copyright @copyright{} 1999 Martin Grabmueller <mgrabmue@@cs.tu-berlin.de>@*
Copyright @copyright{} 2000 Raimund Jacob <raimi@@lkcc.org>@*
Copyright @copyright{} 2000 Stefan Jahn <stefan@@lkcc.org>@*

Verbatim copying and distribution of this entire document is
permitted in any medium, provided this notice is preserved.

@contents
@bye
