@c -*-texinfo-*-
@c
@c This file includes the documentation about the Guile servers.  It is
@c included by `serveez.texi'.
@c

This section describes the Guile interface of Serveez meant to provide
the ability to exceptionally write servers with Guile.  Of course you could
do this without any help of Serveez, but it makes it a lot easier.  The
Guile interface of Serveez reduces the Guile implementation of an Internet
server to a simple data processor.

@subsubsection Special data types

Serveez extends Guile by various new data types which represent internal
data structures of Serveez's core API.

@itemize @bullet
@item @code{#<svz-servertype>}
represents a server type.
@item @code{#<svz-server>}
represents a server (an instance of a server type).
@item @code{#<svz-socket>}
represents a socket structure.
@end itemize

@subsubsection Passing binary data

The new binary data type (i.e. @code{#<svz-binary>}) provides access to any
kind of unstructured data.  It manages data exchange between Guile and Serveez
and the other way around.  There are some converter functions for strings 
and lists which help to process this binary data in a more complex (guile'ish) 
way.

BINARY->STRING_DEFUN
STRING->BINARY_DEFUN
BINARY?_DEFUN
LIST->BINARY_DEFUN
BINARY->LIST_DEFUN
BINARY-SEARCH_DEFUN
BINARY-SET!_DEFUN
BINARY-REF_DEFUN
BINARY-LENGTH_DEFUN
BINARY-CONCAT!_DEFUN
BINARY-SUBSET_DEFUN

@subsubsection Server definition

In order to setup a new server type you use the procedure 
@code{(define-servertype!)}.  This procedure takes one argument which must be
a associative list specifying the server type in detail.  There are 
optional and mandatory elements you can setup in this alist.  The following
example shows the overall syntax of this procedure:

@lisp
(define-servertype! '(

  ;; Mandatory: server type prefix for later use in (define-server!)
  (prefix          . "foo")

  ;; Mandatory: server type description
  (description     . "guile foo server")

  ;; Mandatory for TCP and PIPE servers: protocol detection
  (detect-proto    . foo-detect-proto)

  ;; Optional: global server type initialization
  (global-init     . foo-global-init)

  ;; Optional: server instance initialization
  (init            . foo-init)

  ;; Optional: server instance finalization
  (finalize        . foo-finalize)

  ;; Optional: global server type finalization
  (global-finalize . foo-global-finalize)

  ;; Mandatory for TCP and PIPE servers: socket connection
  (connect-socket  . foo-connect-socket)

  ;; Optional: server instance info
  (info-server     . foo-info-server)

  ;; Mandatory: server type configuration
  (configuration   . (

    ;; The server configuration is an alist (associative list) again.  Each
    ;; item consist of an item name and a list describing the item itself.
    ;; Syntax: (key . (type defaultable default))
    (foo-integer       . (integer  #t 0))
    (foo-integer-array . (intarray #t (1 2 3 4 5)))
    (foo-string        . (string   #t "default-foo-string"))
    (foo-string-array  . (strarray #t ("guile" "foo" "server")))
    (foo-hash          . (hash     #t (("foo" . "bar"))))
    (foo-port          . (portcfg  #t foo-port))
    (foo-boolean       . (boolean  #t #t))
  ))))
@end lisp

DEFINE-SERVERTYPE!_DEFUN

@subsubsection Predefined procedures

The following subset of procedures can be used to implement a Guile server.
They should be used within the callbacks defined in the 
@code{(define-servertype!)} procedure.  Each of these callbacks gets passed
the appropriate arguments needed to stuff into the below procedures.  Please
have a look at the example Guile servers for the very details.

SVZ:SOCK?_DEFUN
SVZ:SOCK:CHECK-REQUEST_DEFUN
SVZ:SOCK:HANDLE-REQUEST_DEFUN
SVZ:SOCK:BOUNDARY_DEFUN
SVZ:SOCK:FLOODPROTECT_DEFUN
SVZ:SOCK:PRINT_DEFUN
SVZ:SOCK:FINAL-PRINT_DEFUN
SVZ:SOCK:NO-DELAY_DEFUN
SVZ:SOCK:RECEIVE-BUFFER_DEFUN
SVZ:SOCK:RECEIVE-BUFFER-REDUCE_DEFUN
SVZ:SOCK:CONNECT_DEFUN
SVZ:SOCK:DISCONNECTED_DEFUN
SVZ:SOCK:KICKED_DEFUN
SVZ:SOCK:IDLE_DEFUN
SVZ:SOCK:IDLE-COUNTER_DEFUN
SVZ:SOCK:DATA_DEFUN
SVZ:SOCK:PARENT_DEFUN
SVZ:SOCK:REFERRER_DEFUN
SVZ:SOCK:SERVER_DEFUN
SVZ:SOCK:LOCAL-ADDRESS_DEFUN
SVZ:SOCK:REMOTE-ADDRESS_DEFUN

SVZ:HTONS_DEFUN
SVZ:NTOHS_DEFUN
SVZ:HTONL_DEFUN
SVZ:NTOHL_DEFUN
SVZ:INET-ATON_DEFUN
SVZ:INET-NTOA_DEFUN

SVZ:SERVER?_DEFUN
SVZ:SERVER:LISTENERS_DEFUN
SVZ:SERVER:CONFIG-REF_DEFUN
SVZ:SERVER:STATE-SET!_DEFUN
SVZ:SERVER:STATE-REF_DEFUN
SVZ:SERVER:STATE->HASH_DEFUN

SERVEEZ-PORT?_DEFUN
SERVEEZ-SERVER?_DEFUN
SERVEEZ-SERVERTYPE?_DEFUN
SERVEEZ-EXCEPTIONS_DEFUN
SERVEEZ-NUKE_DEFUN

GETRPC_DEFUN
SETRPC_DEFUN
PORTMAP_DEFUN
PORTMAP-LIST_DEFUN

@subsubsection Callback prototypes

The Guile interface of Serveez is completely callback driven.  Callbacks
can be set within the associative list passed to
@code{(define-servertype!)} or by using the predefined procedures
described in the above section.  Each of the callbacks gets certain
arguments passed and is meant to return specific values to indicate
success or failure.  This section describes each of of these callbacks.

@table @code
@item (global-init #<svz-servertype>)
This callback is executed once for every type of server right after the
@code{(define-servertype!)} statement.  Here you can initialize data or 
whatever is shared between all instances of your server type.  The callback 
is optional and can be set within @code{(define-servertype!)}.  It should
return zero to indicate success and non-zero to indicate failure.  If the
global initializer fails Serveez refuses to register the server type.

@item (global-finalize #<svz-servertype>)
If you want to free shared resources which were possibly allocated within
the global initializer you can do so here.  The callback is run when Serveez
shuts down (issued by @code{(serveez-nuke)}) or the server type gets 
unregistered for some reason.  It is meant to return zero to signal success.
The callback can be setup in @code{(define-servertype!)} and is optional.

@item (init #<svz-server>)
Within this routine you can initialize everything you might need for a single
instance of your server.  The callback is executed for each server instance
which has been created by @code{(define-server!)} and should return zero to
indicate success, otherwise Serveez rejects the server instance.  The callback
can be setup in @code{(define-servertype!)} and is optional.

@item (finalize #<svz-server>)
The server instance finalizer gets its instance representation as argument
passed.  You need to free all resources used by this server instance which
might have been allocated within the server instance initializer or consumed
during runtime.  You can set this callback in the @code{(define-servertype!)}
statement.  The callback is optional and should return zero to indicate
success.

@item (detect-proto #<svz-server> #<svz-socket>)
Because it is possible to have more than one server instance listening on 
one network port (for connection oriented protocols like TCP and PIPE only)
we need to detect the type of client which is connecting to this port.  This 
routine is getting two arguments where the first one is the server instance
and the second is the client socket object containing all information of the 
client connection.  For successful client detection you need to return a 
non-zero value.  You can set up this callback in the 
@code{(define-servertype!)} statement.  This is mandatory for servers which 
get bound to connection oriented protocol (TCP and PIPE) port configurations
by @code{(bind-server!)}.

@item (connect-socket #<svz-server> #<svz-socket>)
If the client detection signaled success this routine is called to assign
the client connection to the server instance.  The arguments are just
the same as in the detection routine.  In this callback you can assign
all the connection specific callbacks for your server and do some initial
things.  Basically you should specify the @code{handle-request} and/or
@code{check-request} callback.  This can be achieved by calling 
@code{(svz:sock:handle-request)} and @code{(svz:sock:check-request)}.  The
@code{connect-socket} callback is also mandatory for connection oriented
protocols and must by defined inside @code{(define-servertype!)}.  On 
success you should return zero.  Otherwise the connection will be shutdown 
by Serveez.

@item (info-server #<svz-server>)
This callback gets executed when requested by the builtin
@ref{Control Protocol Server}.  The callback is optional and can be setup
inside @code{(define-servertype!)}.  The returned character string can be 
multilined separated by @code{\r\n} (but without trailing separator).
Usually you will return information about the server instance configuration
and/or state.

@item (info-client #<svz-server> #<svz-socket>)
This callback is optional.  You can setup it in the 
@code{(define-servertype!)} procedure.  It is meant to provide socket 
structure (which is a client/child of the given server instance) specific
information.  You need to return a single line character string without
trailing newlines.  The provided information can be requested by the 
builtin @ref{Control Protocol Server}.

@item (notify #<svz-server>)
The server instance notifier callback will be run whenever there is some 
time left.  In fact it is run approximately once a second.  A server 
instance can use it to perform periodical tasks.  The callback is also 
optional and can be setup within @code{(define-servertype!)}.

@item (handle-request #<svz-socket> #<svz-binary> size)
Usually this callback gets executed by the @code{check-request} callback 
when it detected a complete packet in the receive buffer.  The callback gets
the packet data passed as a @code{#<svz-binary>}.  The @var{size} argument
is passed for convenience specifying the length of the packet in bytes.
There are two different return value meanings.  For connection oriented
protocols (TCP and PIPE) zero indicates success and non-zero failure.  On 
failure Serveez will shutdown the connection.  For packet oriented protocols
(UDP and ICMP) a non-zero return value indicates that your server was able
to process the passed packet data, otherwise (zero return value) the packet
can be passed to other servers listening on the same port configuration.  
This callback must be specified within @code{(define-servertype!)} for 
packet oriented protocols (UDP and ICMP) and is optional otherwise.  You can
modify the callback by calling @code{(svz:sock:handle-request)}.

@item (check-request #<svz-socket>)
This callback is run whenever new data arrived in the receive buffer.  The
receive buffer of the given @code{#<svz-socket>} can be obtained by 
@code{(svz:sock:receive-buffer)}.  The callback is initially not set and can
be setup by @code{(svz:sock:check-request)}.  Its purpose is to check whether
a complete request was received, and if it was, it should be handled (by
running the @code{handle-request} callback) and removed from the receive 
buffer.  This can be achieved using @code{(svz:sock:receive-buffer-reduce)}.
The callback is for connection oriented protocols (TCP and PIPE) only.  You
should return zero to indicate success and non-zero to indicate failure.  On
failure Serveez shuts the connection down.

@item (disconnected #<svz-socket>)
The @code{disconnected} callback gets called whenever the socket is lost for
some external reason and is going to be shutdown by Serveez.  It can be setup
by @code{(svz:sock:disconnected)}.

@item (kicked #<svz-socket> reason)
This callback gets called whenever the socket gets closed by Serveez 
intentionally.  It can be setup via @code{(svz:sock:kicked)}.  The 
@var{reason} argument can be either @code{KICK_FLOOD} indicating the socket
is a victim of the builtin flood protection or @code{KICK_QUEUE} which 
indicates a send buffer overflow.

@item (idle #<svz-socket>)
The @code{idle} callback gets called from the periodic task scheduler.  
Whenever the @code{idle-counter} is non-zero, it is decremented and
the callback itself gets called when the counter drops to zero.  The
@code{idle} callback can reset the @code{idle-counter} with the procedure
@code{(svz:sock:idle-counter)} to some value and thus can re-schedule itself 
for a later task.  You can setup this callback with @code{(svz:sock:idle)}.
@end table
