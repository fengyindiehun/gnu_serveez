@c -*-texinfo-*-
@c
@c This file includes the embedding documentation.
@c It is included by `serveez.texi'.
@c

This chapter documents how to embed Serveez into C programs and describes
all parts of the API it provides.

The Serveez core library provides all of the functionality necessary in
order to write Internet protocol servers (currently TCP, UDP, ICMP and RAW
sockets), pipe servers (connection oriented via a pair of named pipes) and
coservers in a portable way.  All of the included servers coming with this
package are based upon this library.  It encapsulates the native network and
file system programming interface of different Unices and Windows systems.

The following sections will give the reader
an overview about how to use its core library.

@menu
* Embedding Serveez::     How to embed Serveez into C programs
* Embedding API::         Description of functions and data in the library
@end menu

@node Embedding Serveez
@section Embedding Serveez

This chapter deals with embedding the Serveez core library into standalone
C/C++ applications and using it in order to write additional servers.

@menu
* Compiling and linking::      How to compile and link against the library
* A simple example::           A very small example showing the basics
@end menu

@node Compiling and linking
@subsection Compiling and linking

When you have installed a version of Serveez passing the @file{configure}
script the @code{$prefix} argument e.g., @samp{./configure --prefix=/usr/local}
you will find the @file{libserveez} library in @file{/usr/local/lib} and the
include headers in @file{/usr/local/include}.  If you want to compile a C
program using the Serveez API and link against the Serveez core library
@code{libserveez}, which is @file{libserveez.so} at Unices and
@file{libserveez.dll} at Windows systems, you need to tell the compiler and
linker where to find the headers and libraries.

Most C compilers you can use will understand the following command line
options for this purpose.  The @samp{-I} argument specifies the path to
additional include headers, the @samp{-L} argument the path to additional
libraries and the @samp{-l} argument the library itself to link against.

@example
$ cc svztest.c -I/usr/local/include -o svztest -L/usr/local/lib -lserveez
@end example

In order to obtain the correct compiler and linker flag you can also
run the @samp{serveez-config} script which gets installed with the Serveez
package.  The @samp{serveez-config} script can be invoked with the
following set of option.

@table @code
@item -h, --help
Displays the usage information.
@item -v, --version
Displays installed Serveez version.
@item -l, --ldflags
Prints the linker flags (libraries to link with including path information).
@item -c, --cflags
Prints the compiler flags to compile with.
@end table

@node A simple example
@subsection A simple example

The following small example shows how to use the Serveez core library to
print the list of known network interface.  As you will notice there are three
major steps to do: Include the library header with
@code{#include <libserveez.h>}, initialize the library via @code{svz_boot}
and finalize it via @code{svz_halt}.  In between these calls you can use
all of the API functions, variables and macros described in
@ref{Embedding API}.

@example
#include <libserveez.h> /* Include the library header.  */

int
main (int argc, char **argv)
@{
  svz_boot ();          /* Library initialization.  */
  svz_interface_list ();
  svz_halt ();          /* Library finalization.  */
  return 0;
@}
@end example

@node Embedding API
@section Embedding API

In this chapter the reader will find a short description of each function,
global variable and macro the core library of Serveez provides.  The API can
either be used to implement a new server or coserver module for use with
Serveez or for supporting network and server functionality within your own
applications without caring about the details and system programming.

Most of the Serveez core library interface functionality should be
prefixed with @code{svz_}.  Small symbols will refer to functions and
variables in most cases and big letter symbols refer to macros.

[FIXME: The subsections are named inconsistently because
originally, the API reference was a separate document; on merge,
weirdness like ``Port config funcs'' was necessary to avoid
conflict with the other ``Port configuration'' node.]

@menu
* Library features::      A high-level list of what libserveez provides
* Memory management::     How memory is managed in Serveez
* Data structures::       Data structure helpers
* Utility functions::     Miscellaneous helper functions
* Core functions::        Network core implementations
* Client connections::    Client connection functions
* Socket management::     Socket management functions
* Coserver functions::    Coserver interface
* Codec functions::       Codec interface
* Server types::          Server type implementations
* Server functions::      Server object functions
* Port config funcs::     Port configuration functions
* Booting::               Configuration and boot functions
* Interface::             Network interface function implementation
* Windoze::               Windows port implementations
@end menu

@node Library features
@subsection Library features

The @file{configure} script used to build libserveez takes many options
(@pxref{Build and install}).
Some of these are encapsulated by @code{svz_library_features}.

|F| svz_library_features

@noindent
Here is a table describing the features in detail:

@table @code
@item debug
Present when @samp{--enable-debug}.
@item heap-counters
Present when @samp{--enable-heap-count}.
@item interface-list
Present when @samp{--enable-iflist}.
@item poll
Present when @samp{--enable-poll} and you have poll(2).
@item sendfile
Present when @samp{--enable-sendfile} and you have sendfile(2)
or some workalike (e.g., @code{TransmitFile}).
@item log-mutex
Present when @code{svz_log} uses a mutex around its internal
stdio operations, implying that you have some kind of thread
capability (perhaps in a separate library).
If your system has @code{fwrite_unlocked}, the configure script
assumes that @code{fwrite} et al are already locked and disables this.
@item flood-protection
Present when @samp{--enable-flood}.
@item core
The networking core.  This is always present.
@end table

@node Memory management
@subsection Memory management

The core library of Serveez is able to keep track of the memory an
application or part of a program consumes and also controls itself in the
same manner.  When you are using this memory allocator interface you can
determine and afterwards remove memory leaks.  This is a very important
feature if you consider servers being long term programs.

The three allocator function pointers for @code{malloc}, @code{realloc}
and @code{free} make it possible to instruct Serveez to use different
kinds of memory, which might be necessary if you want the library to work
with shared memory arenas or any other underlying memory API.

|F| svz_set_mm_funcs

|F| svz_malloc
|F| svz_calloc
|F| svz_realloc
|F| svz_free
|M| svz_free_and_zero
|F| svz_strdup

|F| svz_pmalloc
|F| svz_prealloc
|F| svz_pstrdup

|F| svz_get_curalloc

@node Data structures
@subsection Data structures

Since most servers need to store information about its clients or want to
keep track of data during runtime we implemented some of the most useful
data pools.  The actual aim was to provide higher level data structures which
the programming language C does not support.  Some of the included servers
which come with Serveez make extensive use of them.

@menu
* Array::                 A growable array implementation
* Hashtable::             Hashtable implementation
@end menu

@node Array
@subsubsection Array

The array data structure is a simple array implementation.  Each array has got
a size and capacity.  The array indices range from zero to the arrays size
minus one.  You can put any kind of data into this array which fits into the
size of a pointer.  The array automatically grows if necessary.

|F| svz_array_create
|F| svz_array_destroy
|F| svz_array_destroy_zero
|F| svz_array_get
|F| svz_array_set
|F| svz_array_add
|F| svz_array_del
|F| svz_array_size
|F| svz_array_ins
|M| svz_array_foreach

@node Hashtable
@subsubsection Hashtable

A hashtable associates keys of arbitrary size and content with values.
This data structure is also called associative array sometimes because you
use keys in order to access values instead of numbers.  You cannot store
two values associated with the same key.  The values can have any simple
C types like integers or pointers.

|F| svz_hash_create
|F| svz_hash_destroy
|F| svz_hash_delete
|F| svz_hash_put
|F| svz_hash_get
|F| svz_hash_foreach
|F| svz_hash_values
|F| svz_hash_keys
|F| svz_hash_xfree
|F| svz_hash_size
|F| svz_hash_contains
|F| svz_hash_exists

@node Utility functions
@subsection Utility functions

Within this section you will find some miscellaneous functionality and
left overs of the C API.

|F| svz_log
|F| svz_log_setfile

|M| SVZ_NUM2PTR
|M| SVZ_PTR2NUM

|F| svz_hexdump
|F| svz_itoa
|F| svz_atoi
|F| svz_getcwd
|F| svz_openfiles
|F| svz_time
|F| svz_tolower
|F| svz_sys_version

|F| svz_socket_unavailable_error_p

|F| svz_sys_strerror

The next two functions log (with @code{SVZ_LOG_ERROR}) the
current @dfn{system error} or @dfn{network error},
forming the prefix of the message using @var{fmt} and @var{args}.
This formatted prefix cannot exceed 255 bytes.
The rest of the message comprises: colon, space,
error description, newline.

|F| svz_log_sys_error
|F| svz_log_net_error

|F| svz_mingw_at_least_nt4_p

@node Core functions
@subsection Networking and other low level functions

The following chapter deals with the basic networking and file systems
functions.  It encapsulates systems calls in a portable manner.  These
functions should behave identical on Windows and Unices.

|F| svz_inet_ntoa
|F| svz_inet_aton
|F| svz_closesocket
|F| svz_fd_cloexec
|F| svz_tcp_cork
|F| svz_tcp_nodelay
|F| svz_sendfile
|F| svz_open
|F| svz_close
|F| svz_fstat
|F| svz_fopen
|F| svz_fclose

@node Client connections
@subsection Client connections

Serveez tries to handle all kinds of Internet protocols like TCP (connection
oriented), UDP, ICMP and RAW (packet oriented) and communication across
named pipes (also connection oriented) in the same way.  Therefore it uses
a structure called @code{svz_socket_t} which is the abstraction of any kind
of communication endpoint (can be client or server or both together).

@menu
* TCP sockets::                   TCP socket functions
* Pipe connections::              Named and anonymous pipe functions
* UDP sockets::                   UDP socket functions
* ICMP sockets::                  ICMP socket functions
* Raw sockets::                   Raw socket functions
* Passthrough connections::       Passthrough connections to child processes
@end menu

@node TCP sockets
@subsubsection TCP sockets

TCP sockets provide a reliable, stream oriented, full duplex connection
between two sockets on top of the Internet Protocol (IP).  TCP guarantees
that the data arrives in order and retransmits lost packets.  It generates
and checks a per packet checksum to catch transmission errors.  TCP does
not preserve record boundaries.

|F| svz_tcp_connect
|F| svz_tcp_read_socket
|F| svz_tcp_send_oob

@node Pipe connections
@subsubsection Pipe connections

The pipe implementations supports both named and anonymous pipes.  Pipe
servers are implemented as listeners on a file system FIFO on Unices or
"Named Pipes" on Windows (can be shared over a Windows network).

A FIFO special file is similar to a pipe, except that it is created in a
different way.  Instead of being an anonymous communications channel,
a FIFO special file is entered into the file system.

Once you have created a FIFO special file in this way, any process can open
it for reading or writing, in the same way as an ordinary file.  However,
it has to be open at both ends simultaneously before you can proceed to do
any input or output operations on it.

|F| svz_pipe_create
|F| svz_pipe_create_pair
|F| svz_pipe_connect
|F| svz_invalid_handle_p
|F| svz_invalidate_handle
|F| svz_closehandle

@node UDP sockets
@subsubsection UDP sockets

The UDP sockets implement a connectionless, unreliable datagram packet
service.  Packets may be reordered or duplicated before they arrive.  UDP
generates and checks checksums to catch transmission errors.

|F| svz_udp_connect
|F| svz_udp_write
|F| svz_udp_printf

@node ICMP sockets
@subsubsection ICMP sockets

The ICMP socket implementation is currently used in the tunnel server which
comes with the Serveez package.  It implements a user protocol receiving and
sending ICMP packets by opening a raw socket with the protocol IPPROTO_ICMP.

The types of ICMP packets passed to the socket can be filtered using the
ICMP_FILTER socket option (or by software as done here).  ICMP packets are
always processed by the kernel too, even when passed to a user socket.

|F| svz_icmp_connect
|F| svz_icmp_send_control
|F| svz_icmp_write

@node Raw sockets
@subsubsection Raw sockets

A raw socket receives or sends the raw datagram not including link
level headers.  It is currently used by the ICMP socket implementation of
the core library.  The IPv4 layer generates an IP header when sending a packet
unless the IP_HDRINCL socket option is enabled on the socket.  When it is
enabled, the packet must contain an IP header.  For receiving the IP header
is always included in the packet.

Only processes with an effective userid of 0 (Administrator or root) or the
CAP_NET_RAW capability are allowed to open raw sockets.  All packets or errors
matching the protocol number specified for the raw socket are passed to
this socket.  A protocol of IPPROTO_RAW implies enabled IP_HDRINCL and
receives all IP protocols.  Sending is not allowed.

[FIXME: All funcs internalized!  Write something else here!]

@node Passthrough connections
@subsubsection Passthrough connections

The function subset described in the following section allows the user to
passthrough client connections to the standard input (stdin) and standard
output (stdout) handles of external programs.  Some of the routines deal
with the management of program environments.  Basically there are two
methods how to passthrough a duplex connection: the Unix'ish @code{fork}
and @code{exec} method and the shuffle method where the main process
keeps control over the communication on the original duplex connection and
passes this data through two pairs of pipes or yet another socket connection
to the child process.  All of the three method are implemented calling them
@code{SVZ_PROCESS_FORK}, @code{SVZ_PROCESS_SHUFFLE_PIPE} and
@code{SVZ_PROCESS_SHUFFLE_SOCK}.

|F| svz_sock_process

@strong{Please note}:
On M$-Windows platforms it is not possible to pass a socket connection
to a child process's stdin/stdout.  That is why this function creates an
inheritable version of the socket and puts the socket handle number
into the environment variables @code{SEND_HANDLE} and @code{RECV_HANDLE}.
A spawned child process can use these handles as if these were created
by itself.  After calling @code{WSAStartup} the child process can
@code{send} and @code{recv} as usual.

Relatedly, Windoze does not use @code{SIGCHLD} to inform the parent when a
child dies, so for that platform, so should use the next function (which is
not otherwise available):
|F| svz_mingw_child_dead_p

On non-Windoze, this is the function you want to use:
|F| svz_most_recent_dead_child_p

|F| svz_envblock_setup
|F| svz_envblock_create
|F| svz_envblock_default
|F| svz_envblock_add
|F| svz_envblock_destroy
|F| svz_envblock_get

@node Socket management
@subsection Socket management

The function subset described in the following section deals with the
creation, destruction and other simple operations on socket structures
called @code{svz_socket_t}.  See for the details at the description of each
function which kind of socket it can handle and what they are for.

|F| svz_sock_nconnections
|F| svz_sock_write
|F| svz_sock_printf
|F| svz_sock_resize_buffers
|F| svz_sock_check_request
|F| svz_sock_reduce_recv
|F| svz_sock_reduce_send

@node Coserver functions
@subsection Coserver functions

The following section describes the internal coserver interface of serveez.
Coservers are helper processes meant to perform blocking tasks.  This is
going to be necessary because serveez itself is single threaded.  Each
coserver is connected via a pair of pipes to the main thread of serveez
communicating over a simple text line protocol.  Each request/response is
separated by a newline character.

|F| svz_foreach_coserver
|F| svz_coserver_check
|F| svz_coserver_destroy
|F| svz_coserver_create
|F| svz_coserver_type_name

|F| svz_coserver_rdns_invoke
|F| svz_coserver_dns_invoke
|F| svz_coserver_ident_invoke

If the user wants to use these processes you need to start the coserver
interface by calling @code{svz_coserver_updn} once before, and once after,
entering the main server loop.

|F| svz_coserver_updn

@node Codec functions
@subsection Codec functions

The codec interface of the serveez core API supplies routines for setting up
socket structures to perform encoding or decoding of its receive or send
buffers.  It is a transparent layer of buffer transition.  The interface itself
tries to unify different types of codecs.  In order to add a new codec the
programmer needs to write some wrapper functions around the actual
implementation to fulfil certain entry and exit semantics of this interface.

|F| svz_codec_list
|F| svz_codec_get
|F| svz_codec_ratio
|F| svz_codec_register
|F| svz_codec_unregister
|F| svz_codec_sock_receive_setup
|F| svz_codec_sock_receive
|F| svz_codec_sock_send_setup
|F| svz_codec_sock_send
|F| svz_codec_sock_disconnect
|F| svz_codec_sock_detect

@node Server types
@subsection Server types

As already noted in the main serveez manual a server type is the
main specification of the abilities and configuration items of a server
which can be instantiated.  It is represented by the C structure
@code{svz_servertype_t} in serveez.  It contains server specific members
like its name, different callbacks, a single default configuration and a
list of configuration items which determines what can be configured.

@menu
* Macros for setting up a new server type::
* General server type functionality::
* Dynamic server loading::
@end menu

@node Macros for setting up a new server type
@subsubsection Macros for setting up a new server type

When specifying a server type you also need to define configuration items
for it.  These items refer to addresses in the example configuration of the
server type.  The following macros can be used to determine these items.

|M| SVZ_REGISTER_INT
|M| SVZ_REGISTER_BOOL
|M| SVZ_REGISTER_INTARRAY
|M| SVZ_REGISTER_STR
|M| SVZ_REGISTER_STRARRAY
|M| SVZ_REGISTER_HASH
|M| SVZ_REGISTER_PORTCFG
|M| SVZ_REGISTER_END
|M| SVZ_CONFIG_DEFINE

@node General server type functionality
@subsubsection General server type functionality

The following set of functions are used to manage the list of known server
types in the serveez core library.  Serveez itself uses some of these functions
to register its builtin server types.

|F| svz_servertype_add
|F| svz_servertype_get
|F| svz_servertype_find
|F| svz_servertype_print

@node Dynamic server loading
@subsubsection Dynamic server loading

The core API of serveez is able to register server types dynamically at
runtime.  It uses the dynamic linker capabilities of the underlying operating
system to load shared libraries (or DLLs on Win32).  This has been
successfully tested on Windows and GNU/Linux.  Other systems are supported
but yet untested.  Please tell us if noticing any misbehaviour.

|F| svz_dynload_path_set
|F| svz_dynload_path_get

@node Server functions
@subsection Server functions

A server in serveez is an instantiated (configured) server type.  It is
merely a copy of a specific server type with a unique server name.  It is
represented by the C structure @code{svz_server_t} in the core library.

@menu
* Server functionality::  General server instance implementations
* Server configuration::  Server instance configuration
* Server binding::        Server instance bindings
* Server core::           Core functionality for servers
* Server loop::           Server loop implementation
* Server socket::         Using and creating server sockets
@end menu

@node Server functionality
@subsubsection Server functionality

The following section contains functions dealing with the list of known
servers in the core library of serveez, also with the basics like creation
and destruction of such servers.

|F| svz_server_foreach
|F| svz_server_find
|F| svz_server_clients
|F| svz_server_get
|F| svz_server_all_updn

@node Server configuration
@subsubsection Configuration

These functions provide an interface for configuring a server.  They are
used to create and modify the default configuration of a server type in
order to create a server configuration.

|F| svz_config_type_instantiate
|F| svz_config_free
|F| svz_config_intarray_create
|F| svz_config_strarray_create
|F| svz_config_hash_create

@node Server binding
@subsubsection Bindings

The following functionality represents the relationship between port
configurations as described in @ref{Port config funcs} and server
instances.  When binding a server to a specific port configuration the
core library creates listeners as needed by itself.

|F| svz_server_bind
|F| svz_server_portcfgs
|F| svz_server_bindings
|F| svz_server_listeners
|F| svz_server_single_listener
|F| svz_sock_servers

@node Server core
@subsubsection Server core

|V| svz_child_died
|F| svz_shutting_down_p

|F| svz_foreach_socket
|F| svz_sock_find
|F| svz_sock_schedule_for_shutdown
|F| svz_sock_enqueue
|F| svz_sock_setparent
|F| svz_sock_getparent
|F| svz_sock_setreferrer
|F| svz_sock_getreferrer
|F| svz_sock_portcfg

@node Server loop
@subsubsection Server loop

This paragraph describes the main server loop functionality.  There two modes
of operation.  The default mode as used in serveez is to jump into the loop
and waiting until the core library drops out of it.  The user can also tell
the serveez core library to pass its socket chain once and return
immediately.  Thus you are able to issue additional functionality in between
each pass if you cannot handle this within the timers (notifiers) of servers
and sockets.

|F| svz_loop_pre
|F| svz_loop_post
|F| svz_loop
|F| svz_loop_one

@node Server socket
@subsubsection Server sockets

The next section deals with creating and handling listeners.  The functions
below provide the default routines invoked when accepting a new connection
on a listener.  This is necessary for connection oriented protocols (TCP and
named pipes) only.

[FIXME: All funcs internalized!  Write something else here!]

@node Port config funcs
@subsection Port configurations

A port configuration is a structure defining a network or file system
configuration.  Depending on the type of a server it can be bound to one
or more port configurations.  There are two major types of port
configurations: connection and packet oriented protocol port configurations.
TCP and PIPE configurations are connection oriented and ICMP, UDP and
RAW configurations are packet oriented.

|F| svz_portcfg_addr
|F| svz_portcfg_port
|F| svz_portcfg_ipaddr
|F| svz_portcfg_device

Serveez holds a list of port configurations.  Each configuration is
identified by its name.  When you bind a server to a port configuration it
does not get bound to a certain name but to its content.  If there are two
or more port configuration specifying the same network or file system
configuration just a single one gets actually used.

|F| svz_portcfg_create
|F| svz_portcfg_equal
|F| svz_portcfg_add
|F| svz_portcfg_get
|F| svz_portcfg_destroy
|F| svz_portcfg_mkaddr
|F| svz_portcfg_print
|F| svz_portcfg_dup

@node Booting
@subsection Boot functions

The most important functions are
@code{svz_boot} and @code{svz_halt} which must be the first and the last
call to the core API.

|F| svz_boot
|F| svz_uptime
|F| svz_halt

@subsubsection Runtime parameters

There are several runtime parameters
indicating the abilities of the libserveez core API:

@table @code
@item SVZ_RUNPARM_VERBOSITY
The log-level verbosity.
@item SVZ_RUNPARM_MAX_SOCKETS
Maxium number of clients allowed to connect.
@end table

These are manipulated by @code{svz_runparm} and two convenience macros,
both of which accept @dfn{nick}, a C token without the prefix
@samp{SVZ_RUNPARM_} (e.g., @code{VERBOSITY}).

|F| svz_runparm
|M| SVZ_RUNPARM
|M| SVZ_RUNPARM_X

@node Interface
@subsection Network interface functions

The network interface functions of the serveez core API allow the access
to the network devices on your system.  The system administrator can setup
these devices to be bound to different Internet addresses and thereby split
the network configuration into different "domains".  Thus the system is able
to separate traffic of different networks.  If setup correctly serveez can
follow these rules.

|F| svz_foreach_interface
|F| svz_interface_list
|F| svz_interface_add

@node Windoze
@subsection Useful Windows functions

Serveez is meant to run on Windows systems as well (with some restrictions
of course).  The following functions come up with the Windows implementation
of the serveez core API only.  They allow access to the Windows registry
database and some other useful things.

|F| svz_windoze_start_daemon
|F| svz_windoze_stop_daemon
|F| svz_windoze_asc2uni
|F| svz_windoze_uni2asc
